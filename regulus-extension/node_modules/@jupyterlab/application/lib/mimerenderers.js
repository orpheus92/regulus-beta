"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
Object.defineProperty(exports, "__esModule", { value: true });
var apputils_1 = require("@jupyterlab/apputils");
var docregistry_1 = require("@jupyterlab/docregistry");
var layoutrestorer_1 = require("./layoutrestorer");
/**
 * Create rendermime plugins for rendermime extension modules.
 */
function createRendermimePlugins(extensions) {
    var plugins = [];
    extensions.forEach(function (mod) {
        var data = mod.default;
        // Handle commonjs exports.
        if (!mod.hasOwnProperty('__esModule')) {
            data = mod;
        }
        if (!Array.isArray(data)) {
            data = [data];
        }
        data.forEach(function (item) {
            var plugin = createRendermimePlugin(item);
            plugins.push(plugin);
        });
    });
    return plugins;
}
exports.createRendermimePlugins = createRendermimePlugins;
/**
 * Create rendermime plugins for rendermime extension modules.
 */
function createRendermimePlugin(item) {
    return {
        id: "jupyter.services.mimerenderer-" + item.name,
        requires: [layoutrestorer_1.ILayoutRestorer],
        autoStart: true,
        activate: function (app, restorer) {
            // Add the mime renderer.
            if (item.rank !== undefined) {
                app.rendermime.addFactory(item.rendererFactory, item.rank);
            }
            else {
                app.rendermime.addFactory(item.rendererFactory);
            }
            // Handle the widget factory.
            if (!item.documentWidgetFactoryOptions) {
                return;
            }
            var registry = app.docRegistry;
            var options = [];
            if (Array.isArray(item.documentWidgetFactoryOptions)) {
                options = item.documentWidgetFactoryOptions;
            }
            else {
                options = [item.documentWidgetFactoryOptions];
            }
            if (item.fileTypes) {
                item.fileTypes.forEach(function (ft) {
                    app.docRegistry.addFileType(ft);
                });
            }
            options.forEach(function (option) {
                var factory = new docregistry_1.MimeDocumentFactory({
                    renderTimeout: item.renderTimeout,
                    dataType: item.dataType,
                    rendermime: app.rendermime,
                    modelName: option.modelName,
                    name: option.name,
                    primaryFileType: registry.getFileType(option.primaryFileType),
                    fileTypes: option.fileTypes,
                    defaultFor: option.defaultFor
                });
                registry.addWidgetFactory(factory);
                var factoryName = factory.name;
                var namespace = factoryName + "-renderer";
                var tracker = new apputils_1.InstanceTracker({ namespace: namespace });
                // Handle state restoration.
                restorer.restore(tracker, {
                    command: 'docmanager:open',
                    args: function (widget) { return ({ path: widget.context.path, factory: factoryName }); },
                    name: function (widget) { return widget.context.path; }
                });
                factory.widgetCreated.connect(function (sender, widget) {
                    // Notify the instance tracker if restore data needs to update.
                    widget.context.pathChanged.connect(function () { tracker.save(widget); });
                    tracker.add(widget);
                });
            });
        }
    };
}
exports.createRendermimePlugin = createRendermimePlugin;
