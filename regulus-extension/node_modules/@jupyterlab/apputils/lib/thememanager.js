"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
Object.defineProperty(exports, "__esModule", { value: true });
var coreutils_1 = require("@jupyterlab/coreutils");
var algorithm_1 = require("@phosphor/algorithm");
var coreutils_2 = require("@phosphor/coreutils");
var disposable_1 = require("@phosphor/disposable");
/* tslint:disable */
/**
 * The theme manager token.
 */
exports.IThemeManager = new coreutils_2.Token('jupyter.services.theme-manager');
/**
 * A class that provides theme management.
 */
var ThemeManager = (function () {
    /**
     * Construct a new theme manager.
     */
    function ThemeManager(options) {
        var _this = this;
        this._themes = {};
        this._links = [];
        this._pendingTheme = '';
        this._loadedTheme = null;
        this._loadPromise = null;
        this._sealed = false;
        this._baseUrl = options.baseUrl;
        var registry = options.settingRegistry;
        this._host = options.host;
        var id = 'jupyter.services.theme-manager';
        options.when.then(function () {
            _this._sealed = true;
        });
        this.ready = Promise.all([registry.load(id), options.when]).then(function (_a) {
            var settings = _a[0];
            _this._settings = settings;
            _this._settings.changed.connect(_this._onSettingsChanged, _this);
            return _this._handleSettings();
        });
    }
    Object.defineProperty(ThemeManager.prototype, "theme", {
        /**
         * Get the name of the current theme.
         */
        get: function () {
            return this._loadedTheme;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThemeManager.prototype, "themes", {
        /**
         * The names of the registered themes.
         */
        get: function () {
            return Object.keys(this._themes);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set the current theme.
     */
    ThemeManager.prototype.setTheme = function (name) {
        var _this = this;
        return this.ready.then(function () {
            _this._settings.set('theme', name);
        });
    };
    /**
     * Register a theme with the theme manager.
     *
     * @param theme - The theme to register.
     *
     * @returns A disposable that can be used to unregister the theme.
     */
    ThemeManager.prototype.register = function (theme) {
        var _this = this;
        if (this._sealed) {
            throw new Error('Cannot register themes after startup');
        }
        var name = theme.name;
        if (this._themes[name]) {
            throw new Error("Theme already registered for " + name);
        }
        this._themes[name] = theme;
        return new disposable_1.DisposableDelegate(function () {
            delete _this._themes[name];
        });
    };
    /**
     * Load a theme CSS file by path.
     *
     * @param path - The path of the file to load.
     */
    ThemeManager.prototype.loadCSS = function (path) {
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        var baseUrl = coreutils_1.PageConfig.getOption('themePath');
        link.href = coreutils_1.URLExt.join(baseUrl, path);
        var promise = new coreutils_2.PromiseDelegate();
        link.onload = function () {
            promise.resolve(void 0);
        };
        document.body.appendChild(link);
        this._links.push(link);
        return promise.promise;
    };
    /**
     * Handle a change to the settings.
     */
    ThemeManager.prototype._onSettingsChanged = function (sender) {
        this._pendingTheme = sender.composite['theme'];
        if (!this._themes[this._pendingTheme]) {
            return;
        }
        if (this._pendingTheme === this._loadedTheme) {
            return;
        }
        if (this._loadPromise) {
            return;
        }
        this._loadTheme();
    };
    /**
     * Handle the current settings.
     */
    ThemeManager.prototype._handleSettings = function () {
        var settings = this._settings;
        var theme = settings.composite['theme'];
        if (!this._themes[theme]) {
            var old = theme;
            theme = settings.default('theme');
            if (!this._themes[theme]) {
                return Promise.reject('No default theme to load');
            }
            console.warn("Could not find theme \"" + old + "\", loading default theme \"" + theme + "\"");
        }
        this._pendingTheme = theme;
        return this._loadTheme();
    };
    /**
     * Load the theme.
     */
    ThemeManager.prototype._loadTheme = function () {
        var _this = this;
        var newTheme = this._themes[this._pendingTheme];
        var oldPromise = Promise.resolve(void 0);
        var oldTheme = this._themes[this._loadedTheme];
        if (oldTheme) {
            oldPromise = oldTheme.unload();
        }
        this._pendingTheme = '';
        this._loadPromise = oldPromise.then(function () {
            _this._links.forEach(function (link) {
                if (link.parentElement) {
                    link.parentElement.removeChild(link);
                }
            });
            _this._links.length = 0;
            return newTheme.load();
        }).then(function () {
            _this._loadedTheme = newTheme.name;
            _this._finishLoad();
        }).catch(function (error) {
            console.error(error);
        });
        return this._loadPromise;
    };
    /**
     * Handle a load finished.
     */
    ThemeManager.prototype._finishLoad = function () {
        Private.fitAll(this._host);
        this._loadPromise = null;
        if (this._pendingTheme) {
            this._loadTheme();
        }
    };
    return ThemeManager;
}());
exports.ThemeManager = ThemeManager;
/**
 * A namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * Fit a widget and all of its children, recursively.
     */
    function fitAll(widget) {
        algorithm_1.each(widget.children(), fitAll);
        widget.fit();
    }
    Private.fitAll = fitAll;
})(Private || (Private = {}));
