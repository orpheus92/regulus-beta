"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var algorithm_1 = require("@phosphor/algorithm");
var properties_1 = require("@phosphor/properties");
var widgets_1 = require("@phosphor/widgets");
var _1 = require(".");
/**
 * The class name added to toolbars.
 */
var TOOLBAR_CLASS = 'jp-Toolbar';
/**
 * The class name added to toolbar items.
 */
var TOOLBAR_ITEM_CLASS = 'jp-Toolbar-item';
/**
 * The class name added to toolbar buttons.
 */
var TOOLBAR_BUTTON_CLASS = 'jp-Toolbar-button';
/**
 * The class name added to a pressed button.
 */
var TOOLBAR_PRESSED_CLASS = 'jp-mod-pressed';
/**
 * The class name added to toolbar interrupt button.
 */
var TOOLBAR_INTERRUPT_CLASS = 'jp-StopIcon';
/**
 * The class name added to toolbar restart button.
 */
var TOOLBAR_RESTART_CLASS = 'jp-RefreshIcon';
/**
 * The class name added to toolbar kernel name text.
 */
var TOOLBAR_KERNEL_NAME_CLASS = 'jp-Toolbar-kernelName';
/**
 * The class name added to toolbar spacer.
 */
var TOOLBAR_SPACER_CLASS = 'jp-Toolbar-spacer';
/**
 * The class name added to toolbar kernel status icon.
 */
var TOOLBAR_KERNEL_STATUS_CLASS = 'jp-Toolbar-kernelStatus';
/**
 * The class name added to a busy kernel indicator.
 */
var TOOLBAR_BUSY_CLASS = 'jp-FilledCircleIcon';
var TOOLBAR_IDLE_CLASS = 'jp-CircleIcon';
/**
 * A class which provides a toolbar widget.
 */
var Toolbar = (function (_super) {
    __extends(Toolbar, _super);
    /**
     * Construct a new toolbar widget.
     */
    function Toolbar() {
        var _this = _super.call(this) || this;
        _this.addClass(TOOLBAR_CLASS);
        _this.layout = new widgets_1.PanelLayout();
        return _this;
    }
    /**
     * Get an iterator over the ordered toolbar item names.
     *
     * @returns An iterator over the toolbar item names.
     */
    Toolbar.prototype.names = function () {
        var layout = this.layout;
        return algorithm_1.map(layout.widgets, function (widget) {
            return Private.nameProperty.get(widget);
        });
    };
    /**
     * Add an item to the end of the toolbar.
     *
     * @param name - The name of the widget to add to the toolbar.
     *
     * @param widget - The widget to add to the toolbar.
     *
     * @param index - The optional name of the item to insert after.
     *
     * @returns Whether the item was added to toolbar.  Returns false if
     *   an item of the same name is already in the toolbar.
     *
     * #### Notes
     * The item can be removed from the toolbar by setting its parent to `null`.
     */
    Toolbar.prototype.addItem = function (name, widget) {
        var layout = this.layout;
        return this.insertItem(layout.widgets.length, name, widget);
    };
    /**
     * Insert an item into the toolbar at the specified index.
     *
     * @param index - The index at which to insert the item.
     *
     * @param name - The name of the item.
     *
     * @param widget - The widget to add.
     *
     * @returns Whether the item was added to the toolbar. Returns false if
     *   an item of the same name is already in the toolbar.
     *
     * #### Notes
     * The index will be clamped to the bounds of the items.
     * The item can be removed from the toolbar by setting its parent to `null`.
     */
    Toolbar.prototype.insertItem = function (index, name, widget) {
        var existing = algorithm_1.find(this.names(), function (value) { return value === name; });
        if (existing) {
            return false;
        }
        widget.addClass(TOOLBAR_ITEM_CLASS);
        var layout = this.layout;
        layout.insertWidget(index, widget);
        Private.nameProperty.set(widget, name);
        return true;
    };
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the dock panel's node. It should
     * not be called directly by user code.
     */
    Toolbar.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'click':
                if (!this.node.contains(document.activeElement) && this.parent) {
                    this.parent.activate();
                }
                break;
            default:
                break;
        }
    };
    /**
     * Handle `after-attach` messages for the widget.
     */
    Toolbar.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('click', this);
    };
    /**
     * Handle `before-detach` messages for the widget.
     */
    Toolbar.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('click', this);
    };
    return Toolbar;
}(widgets_1.Widget));
exports.Toolbar = Toolbar;
/**
 * The namespace for Toolbar class statics.
 */
(function (Toolbar) {
    /**
     * Create a toolbar item for a command.
     *
     * Notes:
     * If the command has an icon label it will be added to the button.
     * If there is no icon label, and no icon class, the main label will
     * be added.
     */
    function createFromCommand(commands, id) {
        var button = new ToolbarButton({
            onClick: function () { commands.execute(id); },
            className: Private.commandClassName(commands, id),
            tooltip: Private.commandTooltip(commands, id),
        });
        var oldClasses = Private.commandClassName(commands, id).split(/\s/);
        button.node.disabled = !commands.isEnabled(id);
        Private.setNodeContentFromCommand(button.node, commands, id);
        // Ensure that we pick up relevant changes to the command:
        function onChange(sender, args) {
            if (args.id !== id) {
                return; // Not our command
            }
            if (args.type === 'removed') {
                // Dispose of button
                button.dispose();
            }
            else if (args.type === 'changed') {
                // Update all fields (onClick is already indirected)
                var newClasses = Private.commandClassName(sender, id).split(/\s/);
                for (var _i = 0, oldClasses_1 = oldClasses; _i < oldClasses_1.length; _i++) {
                    var cls = oldClasses_1[_i];
                    if (cls && newClasses.indexOf(cls) === -1) {
                        button.removeClass(cls);
                    }
                }
                for (var _a = 0, newClasses_1 = newClasses; _a < newClasses_1.length; _a++) {
                    var cls = newClasses_1[_a];
                    if (cls && oldClasses.indexOf(cls) === -1) {
                        button.addClass(cls);
                    }
                }
                oldClasses = newClasses;
                button.node.title = Private.commandTooltip(sender, id);
                Private.setNodeContentFromCommand(button.node, sender, id);
                button.node.disabled = !sender.isEnabled(id);
            }
        }
        commands.commandChanged.connect(onChange, button);
        return button;
    }
    Toolbar.createFromCommand = createFromCommand;
    /**
     * Create an interrupt toolbar item.
     */
    function createInterruptButton(session) {
        return new ToolbarButton({
            className: TOOLBAR_INTERRUPT_CLASS,
            onClick: function () {
                if (session.kernel) {
                    session.kernel.interrupt();
                }
            },
            tooltip: 'Interrupt the kernel'
        });
    }
    Toolbar.createInterruptButton = createInterruptButton;
    /**
     * Create a restart toolbar item.
     */
    function createRestartButton(session) {
        return new ToolbarButton({
            className: TOOLBAR_RESTART_CLASS,
            onClick: function () {
                session.restart();
            },
            tooltip: 'Restart the kernel'
        });
    }
    Toolbar.createRestartButton = createRestartButton;
    /**
     * Create a toolbar spacer item.
     *
     * #### Notes
     * It is a flex spacer that separates the left toolbar items
     * from the right toolbar items.
     */
    function createSpacerItem() {
        return new Private.Spacer();
    }
    Toolbar.createSpacerItem = createSpacerItem;
    /**
     * Create a kernel name indicator item.
     *
     * #### Notes
     * It will display the `'display_name`' of the current kernel,
     * or `'No Kernel!'` if there is no kernel.
     * It can handle a change in context or kernel.
     */
    function createKernelNameItem(session) {
        return new Private.KernelName(session);
    }
    Toolbar.createKernelNameItem = createKernelNameItem;
    /**
     * Create a kernel status indicator item.
     *
     * #### Notes
     * It show display a busy status if the kernel status is
     * not idle.
     * It will show the current status in the node title.
     * It can handle a change to the context or the kernel.
     */
    function createKernelStatusItem(session) {
        return new Private.KernelStatus(session);
    }
    Toolbar.createKernelStatusItem = createKernelStatusItem;
})(Toolbar = exports.Toolbar || (exports.Toolbar = {}));
exports.Toolbar = Toolbar;
/**
 * A widget which acts as a button in a toolbar.
 */
var ToolbarButton = (function (_super) {
    __extends(ToolbarButton, _super);
    /**
     * Construct a new toolbar button.
     */
    function ToolbarButton(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, { node: document.createElement('button') }) || this;
        _1.Styling.styleNodeByTag(_this.node, 'button');
        _this.addClass(TOOLBAR_BUTTON_CLASS);
        _this._onClick = options.onClick || Private.noOp;
        if (options.className) {
            for (var _i = 0, _a = options.className.split(/\s/); _i < _a.length; _i++) {
                var extra = _a[_i];
                _this.addClass(extra);
            }
        }
        _this.node.title = options.tooltip || '';
        return _this;
    }
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the dock panel's node. It should
     * not be called directly by user code.
     */
    ToolbarButton.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'click':
                if (event.button === 0) {
                    this._onClick();
                }
                break;
            case 'mousedown':
                this.addClass(TOOLBAR_PRESSED_CLASS);
                break;
            case 'mouseup':
            case 'mouseout':
                this.removeClass(TOOLBAR_PRESSED_CLASS);
                break;
            default:
                break;
        }
    };
    /**
     * Handle `after-attach` messages for the widget.
     */
    ToolbarButton.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('click', this);
        this.node.addEventListener('mousedown', this);
        this.node.addEventListener('mouseup', this);
        this.node.addEventListener('mouseout', this);
    };
    /**
     * Handle `before-detach` messages for the widget.
     */
    ToolbarButton.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('click', this);
        this.node.removeEventListener('mousedown', this);
        this.node.removeEventListener('mouseup', this);
        this.node.removeEventListener('mouseout', this);
    };
    return ToolbarButton;
}(widgets_1.Widget));
exports.ToolbarButton = ToolbarButton;
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * An attached property for the name of a toolbar item.
     */
    Private.nameProperty = new properties_1.AttachedProperty({
        name: 'name',
        create: function () { return ''; }
    });
    /**
     * ToolbarButton tooltip formatter for a command.
     */
    function commandTooltip(commands, id) {
        return commands.caption(id);
    }
    Private.commandTooltip = commandTooltip;
    /**
     * A no-op function.
     */
    function noOp() { }
    Private.noOp = noOp;
    /**
     * Get the class names for a command based ToolBarButton
     */
    function commandClassName(commands, id) {
        var name = commands.className(id);
        // Add the boolean state classes.
        if (commands.isToggled(id)) {
            name += ' p-mod-toggled';
        }
        if (!commands.isVisible(id)) {
            name += ' p-mod-hidden';
        }
        return name;
    }
    Private.commandClassName = commandClassName;
    /**
     * Fill the node of a command based ToolBarButton.
     */
    function setNodeContentFromCommand(node, commands, id) {
        var iconClass = commands.iconClass(id);
        var iconLabel = commands.iconLabel(id);
        node.innerHTML = '';
        if (iconClass || iconLabel) {
            var icon = document.createElement('div');
            icon.innerText = commands.iconLabel(id);
            icon.className += " " + iconClass;
            node.appendChild(icon);
        }
        else {
            node.innerText = commands.label(id);
        }
    }
    Private.setNodeContentFromCommand = setNodeContentFromCommand;
    /**
     * A spacer widget.
     */
    var Spacer = (function (_super) {
        __extends(Spacer, _super);
        /**
         * Construct a new spacer widget.
         */
        function Spacer() {
            var _this = _super.call(this) || this;
            _this.addClass(TOOLBAR_SPACER_CLASS);
            return _this;
        }
        return Spacer;
    }(widgets_1.Widget));
    Private.Spacer = Spacer;
    /**
     * A kernel name widget.
     */
    var KernelName = (function (_super) {
        __extends(KernelName, _super);
        /**
         * Construct a new kernel name widget.
         */
        function KernelName(session) {
            var _this = _super.call(this, {
                className: TOOLBAR_KERNEL_NAME_CLASS,
                onClick: function () {
                    session.selectKernel();
                },
                tooltip: 'Switch kernel'
            }) || this;
            _this._onKernelChanged(session);
            session.kernelChanged.connect(_this._onKernelChanged, _this);
            return _this;
        }
        /**
         * Update the text of the kernel name item.
         */
        KernelName.prototype._onKernelChanged = function (session) {
            this.node.textContent = session.kernelDisplayName;
        };
        return KernelName;
    }(ToolbarButton));
    Private.KernelName = KernelName;
    /**
     * A toolbar item that displays kernel status.
     */
    var KernelStatus = (function (_super) {
        __extends(KernelStatus, _super);
        /**
         * Construct a new kernel status widget.
         */
        function KernelStatus(session) {
            var _this = _super.call(this) || this;
            _this.addClass(TOOLBAR_KERNEL_STATUS_CLASS);
            _this._onStatusChanged(session);
            session.statusChanged.connect(_this._onStatusChanged, _this);
            return _this;
        }
        /**
         * Handle a status on a kernel.
         */
        KernelStatus.prototype._onStatusChanged = function (session) {
            if (this.isDisposed) {
                return;
            }
            var status = session.status;
            this.toggleClass(TOOLBAR_IDLE_CLASS, status === 'idle');
            this.toggleClass(TOOLBAR_BUSY_CLASS, status !== 'idle');
            var title = 'Kernel ' + status[0].toUpperCase() + status.slice(1);
            this.node.title = title;
        };
        return KernelStatus;
    }(widgets_1.Widget));
    Private.KernelStatus = KernelStatus;
})(Private || (Private = {}));
