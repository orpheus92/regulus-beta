"use strict";
/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var coreutils_1 = require("@phosphor/coreutils");
var widgets_1 = require("@phosphor/widgets");
var coreutils_2 = require("@jupyterlab/coreutils");
var rendermime_1 = require("@jupyterlab/rendermime");
var outputarea_1 = require("@jupyterlab/outputarea");
var collapser_1 = require("./collapser");
var inputarea_1 = require("./inputarea");
var placeholder_1 = require("./placeholder");
var headerfooter_1 = require("./headerfooter");
/**
 * The CSS class added to cell widgets.
 */
var CELL_CLASS = 'jp-Cell';
/**
 * The CSS class added to the cell header.
 */
var CELL_HEADER_CLASS = 'jp-Cell-header';
/**
 * The CSS class added to the cell footer.
 */
var CELL_FOOTER_CLASS = 'jp-Cell-footer';
/**
 * The CSS class added to the cell input wrapper.
 */
var CELL_INPUT_WRAPPER_CLASS = 'jp-Cell-inputWrapper';
/**
 * The CSS class added to the cell output wrapper.
 */
var CELL_OUTPUT_WRAPPER_CLASS = 'jp-Cell-outputWrapper';
/**
 * The CSS class added to the cell input area.
 */
var CELL_INPUT_AREA_CLASS = 'jp-Cell-inputArea';
/**
 * The CSS class added to the cell output area.
 */
var CELL_OUTPUT_AREA_CLASS = 'jp-Cell-outputArea';
/**
 * The CSS class added to the cell input collapser.
 */
var CELL_INPUT_COLLAPSER_CLASS = 'jp-Cell-inputCollapser';
/**
 * The CSS class added to the cell output collapser.
 */
var CELL_OUTPUT_COLLAPSER_CLASS = 'jp-Cell-outputCollapser';
/**
 * The class name added to the cell when collapsed.
 */
var COLLAPSED_CLASS = 'jp-mod-collapsed';
/**
 * The class name added to the cell when readonly.
 */
var READONLY_CLASS = 'jp-mod-readOnly';
/**
 * The class name added to code cells.
 */
var CODE_CELL_CLASS = 'jp-CodeCell';
/**
 * The class name added to markdown cells.
 */
var MARKDOWN_CELL_CLASS = 'jp-MarkdownCell';
/**
 * The class name added to rendered markdown output widgets.
 */
var MARKDOWN_OUTPUT_CLASS = 'jp-MarkdownOutput';
/**
 * The class name added to raw cells.
 */
var RAW_CELL_CLASS = 'jp-RawCell';
/**
 * The class name added to a rendered input area.
 */
var RENDERED_CLASS = 'jp-mod-rendered';
var NO_OUTPUTS_CLASS = 'jp-mod-noOutputs';
/**
 * The text applied to an empty markdown cell.
 */
var DEFAULT_MARKDOWN_TEXT = 'Type Markdown and LaTeX: $ Î±^2 $';
/**
 * The timeout to wait for change activity to have ceased before rendering.
 */
var RENDER_TIMEOUT = 1000;
/******************************************************************************
 * Cell
 ******************************************************************************/
/**
 * A base cell widget.
 */
var Cell = (function (_super) {
    __extends(Cell, _super);
    /**
     * Construct a new base cell widget.
     */
    function Cell(options) {
        var _this = _super.call(this) || this;
        _this._readOnly = false;
        _this._model = null;
        _this._header = null;
        _this._footer = null;
        _this._inputHidden = false;
        _this._input = null;
        _this._inputCollapser = null;
        _this._inputWrapper = null;
        _this._inputPlaceholder = null;
        _this.addClass(CELL_CLASS);
        var model = _this._model = options.model;
        var contentFactory = _this.contentFactory = (options.contentFactory || Cell.defaultContentFactory);
        _this.layout = new widgets_1.PanelLayout();
        // Header
        var header = _this._header = contentFactory.createCellHeader();
        header.addClass(CELL_HEADER_CLASS);
        _this.layout.addWidget(header);
        // Input
        var inputWrapper = _this._inputWrapper = new widgets_1.Panel();
        inputWrapper.addClass(CELL_INPUT_WRAPPER_CLASS);
        var inputCollapser = _this._inputCollapser = new collapser_1.InputCollapser();
        inputCollapser.addClass(CELL_INPUT_COLLAPSER_CLASS);
        var input = _this._input = new inputarea_1.InputArea({ model: model, contentFactory: contentFactory });
        input.addClass(CELL_INPUT_AREA_CLASS);
        inputWrapper.addWidget(inputCollapser);
        inputWrapper.addWidget(input);
        _this.layout.addWidget(inputWrapper);
        _this._inputPlaceholder = new placeholder_1.InputPlaceholder(function () {
            _this.inputHidden = !_this.inputHidden;
        });
        // Footer
        var footer = _this._footer = _this.contentFactory.createCellFooter();
        footer.addClass(CELL_FOOTER_CLASS);
        _this.layout.addWidget(footer);
        return _this;
    }
    Object.defineProperty(Cell.prototype, "promptNode", {
        /**
         * Get the prompt node used by the cell.
         */
        get: function () {
            if (!this._inputHidden) {
                return this._input.promptNode;
            }
            else {
                return this._inputPlaceholder.node.firstElementChild;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Cell.prototype, "editorWidget", {
        /**
         * Get the CodeEditorWrapper used by the cell.
         */
        get: function () {
            return this._input.editorWidget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Cell.prototype, "editor", {
        /**
         * Get the CodeEditor used by the cell.
         */
        get: function () {
            return this._input.editor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Cell.prototype, "model", {
        /**
         * Get the model used by the cell.
         */
        get: function () {
            return this._model;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Cell.prototype, "inputArea", {
        /**
         * Get the input area for the cell.
         */
        get: function () {
            return this._input;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Cell.prototype, "readOnly", {
        /**
         * The read only state of the cell.
         */
        get: function () {
            return this._readOnly;
        },
        set: function (value) {
            if (value === this._readOnly) {
                return;
            }
            this._readOnly = value;
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Cell.prototype, "ready", {
        /**
         * A promise that resolves when the widget renders for the first time.
         */
        get: function () {
            return Promise.resolve(undefined);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set the prompt for the widget.
     */
    Cell.prototype.setPrompt = function (value) {
        this._input.setPrompt(value);
    };
    Object.defineProperty(Cell.prototype, "inputHidden", {
        /**
         * The view state of input being hidden.
         */
        get: function () {
            return this._inputHidden;
        },
        set: function (value) {
            if (this._inputHidden === value) {
                return;
            }
            var layout = this._inputWrapper.layout;
            if (value) {
                this._input.parent = null;
                layout.addWidget(this._inputPlaceholder);
            }
            else {
                this._inputPlaceholder.parent = null;
                layout.addWidget(this._input);
            }
            this._inputHidden = value;
            this.handleInputHidden(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handle the input being hidden.
     *
     * #### Notes
     * This is called by the `inputHidden` setter so that subclasses
     * can perform actions upon the input being hidden without accessing
     * private state.
     */
    Cell.prototype.handleInputHidden = function (value) {
        return;
    };
    /**
     * Dispose of the resources held by the widget.
     */
    Cell.prototype.dispose = function () {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        this._input = null;
        this._model = null;
        this._header = null;
        this._footer = null;
        this._inputCollapser = null;
        this._inputWrapper = null;
        this._inputPlaceholder = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle `after-attach` messages.
     */
    Cell.prototype.onAfterAttach = function (msg) {
        this.update();
    };
    /**
     * Handle `'activate-request'` messages.
     */
    Cell.prototype.onActivateRequest = function (msg) {
        this.editor.focus();
    };
    /**
     * Handle `update-request` messages.
     */
    Cell.prototype.onUpdateRequest = function (msg) {
        if (!this._model) {
            return;
        }
        // Handle read only state.
        this.editor.setOption('readOnly', this._readOnly);
        this.toggleClass(READONLY_CLASS, this._readOnly);
    };
    return Cell;
}(widgets_1.Widget));
exports.Cell = Cell;
/**
 * The namespace for the `Cell` class statics.
 */
(function (Cell) {
    /**
     * The default implementation of an `IContentFactory`.
     *
     * This includes a CodeMirror editor factory to make it easy to use out of the box.
     */
    var ContentFactory = (function () {
        /**
         * Create a content factory for a cell.
         */
        function ContentFactory(options) {
            if (options === void 0) { options = {}; }
            this._editorFactory = null;
            this._editorFactory = (options.editorFactory || inputarea_1.InputArea.defaultEditorFactory);
        }
        Object.defineProperty(ContentFactory.prototype, "editorFactory", {
            /**
             * The readonly editor factory that create code editors
             */
            get: function () {
                return this._editorFactory;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Create a new cell header for the parent widget.
         */
        ContentFactory.prototype.createCellHeader = function () {
            return new headerfooter_1.CellHeader();
        };
        /**
         * Create a new cell header for the parent widget.
         */
        ContentFactory.prototype.createCellFooter = function () {
            return new headerfooter_1.CellFooter();
        };
        /**
         * Create an input prompt.
         */
        ContentFactory.prototype.createInputPrompt = function () {
            return new inputarea_1.InputPrompt();
        };
        /**
         * Create the output prompt for the widget.
         */
        ContentFactory.prototype.createOutputPrompt = function () {
            return new outputarea_1.OutputPrompt();
        };
        /**
         * Create an stdin widget.
         */
        ContentFactory.prototype.createStdin = function (options) {
            return new outputarea_1.Stdin(options);
        };
        return ContentFactory;
    }());
    Cell.ContentFactory = ContentFactory;
    /**
     * The default content factory for cells.
     */
    Cell.defaultContentFactory = new ContentFactory();
})(Cell = exports.Cell || (exports.Cell = {}));
exports.Cell = Cell;
/******************************************************************************
 * CodeCell
 ******************************************************************************/
/**
 * A widget for a code cell.
 */
var CodeCell = (function (_super) {
    __extends(CodeCell, _super);
    /**
     * Construct a code cell widget.
     */
    function CodeCell(options) {
        var _this = _super.call(this, options) || this;
        _this._rendermime = null;
        _this._outputHidden = false;
        _this._outputWrapper = null;
        _this._outputCollapser = null;
        _this._outputPlaceholder = null;
        _this._output = null;
        _this.addClass(CODE_CELL_CLASS);
        // Only save options not handled by parent constructor.
        var rendermime = _this._rendermime = options.rendermime;
        var contentFactory = _this.contentFactory;
        var model = _this.model;
        // Code cells should not wrap lines.
        _this.editor.setOption('lineWrap', false);
        // Insert the output before the cell footer.
        var outputWrapper = _this._outputWrapper = new widgets_1.Panel();
        outputWrapper.addClass(CELL_OUTPUT_WRAPPER_CLASS);
        var outputCollapser = _this._outputCollapser = new collapser_1.OutputCollapser();
        outputCollapser.addClass(CELL_OUTPUT_COLLAPSER_CLASS);
        var output = _this._output = new outputarea_1.OutputArea({
            model: model.outputs,
            rendermime: rendermime,
            contentFactory: contentFactory
        });
        output.addClass(CELL_OUTPUT_AREA_CLASS);
        // Set a CSS if there are no outputs, and connect a signal for future
        // changes to the number of outputs. This is for conditional styling
        // if there are no outputs.
        if (model.outputs.length === 0) {
            _this.addClass(NO_OUTPUTS_CLASS);
        }
        output.outputLengthChanged.connect(_this._outputLengthHandler, _this);
        outputWrapper.addWidget(outputCollapser);
        outputWrapper.addWidget(output);
        _this.layout.insertWidget(2, outputWrapper);
        _this._outputPlaceholder = new placeholder_1.OutputPlaceholder(function () {
            _this.outputHidden = !_this.outputHidden;
        });
        // Modify state
        _this.setPrompt("" + (model.executionCount || ''));
        model.stateChanged.connect(_this.onStateChanged, _this);
        model.metadata.changed.connect(_this.onMetadataChanged, _this);
        return _this;
    }
    Object.defineProperty(CodeCell.prototype, "outputArea", {
        /**
         * Get the output area for the cell.
         */
        get: function () {
            return this._output;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CodeCell.prototype, "outputHidden", {
        /**
         * The view state of output being collapsed.
         */
        get: function () {
            return this._outputHidden;
        },
        set: function (value) {
            if (this._outputHidden === value) {
                return;
            }
            var layout = this._outputWrapper.layout;
            if (value) {
                layout.removeWidget(this._output);
                layout.addWidget(this._outputPlaceholder);
                if (this.inputHidden && !this._outputWrapper.isHidden) {
                    this._outputWrapper.hide();
                }
            }
            else {
                if (this._outputWrapper.isHidden) {
                    this._outputWrapper.show();
                }
                layout.removeWidget(this._outputPlaceholder);
                layout.addWidget(this._output);
            }
            this._outputHidden = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handle the input being hidden.
     *
     * #### Notes
     * This method is called by the case cell implementation and is
     * subclasses here so the code cell can watch to see when input
     * is hidden without accessing private state.
     */
    CodeCell.prototype.handleInputHidden = function (value) {
        if (!value && this._outputWrapper.isHidden) {
            this._outputWrapper.show();
        }
        else if (value && !this._outputWrapper.isHidden && this._outputHidden) {
            this._outputWrapper.hide();
        }
    };
    /**
     * Dispose of the resources used by the widget.
     */
    CodeCell.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._output.outputLengthChanged.disconnect(this._outputLengthHandler, this);
        this._rendermime = null;
        this._output = null;
        this._outputWrapper = null;
        this._outputCollapser = null;
        this._outputPlaceholder = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle `update-request` messages.
     */
    CodeCell.prototype.onUpdateRequest = function (msg) {
        var value = this.model.metadata.get('collapsed');
        this.toggleClass(COLLAPSED_CLASS, value);
        if (this._output) {
            // TODO: handle scrolled state.
        }
        _super.prototype.onUpdateRequest.call(this, msg);
    };
    /**
     * Handle changes in the model.
     */
    CodeCell.prototype.onStateChanged = function (model, args) {
        switch (args.name) {
            case 'executionCount':
                this.setPrompt("" + (model.executionCount || ''));
                break;
            default:
                break;
        }
    };
    /**
     * Handle changes in the metadata.
     */
    CodeCell.prototype.onMetadataChanged = function (model, args) {
        switch (args.key) {
            case 'collapsed':
            case 'scrolled':
                this.update();
                break;
            default:
                break;
        }
    };
    /**
     * Handle changes in the number of outputs in the output area.
     */
    CodeCell.prototype._outputLengthHandler = function (sender, args) {
        var force = args === 0 ? true : false;
        this.toggleClass(NO_OUTPUTS_CLASS, force);
    };
    return CodeCell;
}(Cell));
exports.CodeCell = CodeCell;
/**
 * The namespace for the `CodeCell` class statics.
 */
(function (CodeCell) {
    /**
     * Execute a cell given a client session.
     */
    function execute(cell, session) {
        var model = cell.model;
        var code = model.value.text;
        if (!code.trim() || !session.kernel) {
            model.executionCount = null;
            model.outputs.clear();
            return Promise.resolve(void 0);
        }
        model.executionCount = null;
        cell.outputHidden = false;
        cell.setPrompt('*');
        model.trusted = true;
        return outputarea_1.OutputArea.execute(code, cell.outputArea, session).then(function (msg) {
            model.executionCount = msg.content.execution_count;
            return msg;
        });
    }
    CodeCell.execute = execute;
})(CodeCell = exports.CodeCell || (exports.CodeCell = {}));
exports.CodeCell = CodeCell;
/******************************************************************************
 * MarkdownCell
 ******************************************************************************/
/**
 * A widget for a Markdown cell.
 *
 * #### Notes
 * Things get complicated if we want the rendered text to update
 * any time the text changes, the text editor model changes,
 * or the input area model changes.  We don't support automatically
 * updating the rendered text in all of these cases.
 */
var MarkdownCell = (function (_super) {
    __extends(MarkdownCell, _super);
    /**
     * Construct a Markdown cell widget.
     */
    function MarkdownCell(options) {
        var _this = _super.call(this, options) || this;
        _this._monitor = null;
        _this._renderer = null;
        _this._rendered = true;
        _this._prevText = '';
        _this._ready = new coreutils_1.PromiseDelegate();
        _this.addClass(MARKDOWN_CELL_CLASS);
        _this._rendermime = options.rendermime;
        // Throttle the rendering rate of the widget.
        _this._monitor = new coreutils_2.ActivityMonitor({
            signal: _this.model.contentChanged,
            timeout: RENDER_TIMEOUT
        });
        _this._monitor.activityStopped.connect(function () {
            if (_this._rendered) {
                _this.update();
            }
        }, _this);
        _this._updateRenderedInput().then(function () {
            _this._ready.resolve(void 0);
        });
        return _this;
    }
    Object.defineProperty(MarkdownCell.prototype, "ready", {
        /**
         * A promise that resolves when the widget renders for the first time.
         */
        get: function () {
            return this._ready.promise;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MarkdownCell.prototype, "rendered", {
        /**
         * Whether the cell is rendered.
         */
        get: function () {
            return this._rendered;
        },
        set: function (value) {
            if (value === this._rendered) {
                return;
            }
            this._rendered = value;
            this._handleRendered();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Render an input instead of the text editor.
     */
    MarkdownCell.prototype.renderInput = function (widget) {
        this.addClass(RENDERED_CLASS);
        this.inputArea.renderInput(widget);
    };
    /**
     * Show the text editor instead of rendered input.
     */
    MarkdownCell.prototype.showEditor = function () {
        this.removeClass(RENDERED_CLASS);
        this.inputArea.showEditor();
    };
    /*
     * Handle `update-request` messages.
     */
    MarkdownCell.prototype.onUpdateRequest = function (msg) {
        // Make sure we are properly rendered.
        this._handleRendered();
        _super.prototype.onUpdateRequest.call(this, msg);
    };
    /**
     * Handle the rendered state.
     */
    MarkdownCell.prototype._handleRendered = function () {
        if (!this._rendered) {
            this.showEditor();
        }
        else {
            this._updateRenderedInput();
            this.renderInput(this._renderer);
        }
    };
    /**
     * Update the rendered input.
     */
    MarkdownCell.prototype._updateRenderedInput = function () {
        var model = this.model;
        var text = model && model.value.text || DEFAULT_MARKDOWN_TEXT;
        // Do not re-render if the text has not changed.
        if (text !== this._prevText) {
            var mimeModel = new rendermime_1.MimeModel({ data: { 'text/markdown': text } });
            if (!this._renderer) {
                this._renderer = this._rendermime.createRenderer('text/markdown');
                this._renderer.addClass(MARKDOWN_OUTPUT_CLASS);
            }
            this._prevText = text;
            return this._renderer.renderModel(mimeModel);
        }
        return Promise.resolve(void 0);
    };
    return MarkdownCell;
}(Cell));
exports.MarkdownCell = MarkdownCell;
/******************************************************************************
 * RawCell
 ******************************************************************************/
/**
 * A widget for a raw cell.
 */
var RawCell = (function (_super) {
    __extends(RawCell, _super);
    /**
     * Construct a raw cell widget.
     */
    function RawCell(options) {
        var _this = _super.call(this, options) || this;
        _this.addClass(RAW_CELL_CLASS);
        return _this;
    }
    return RawCell;
}(Cell));
exports.RawCell = RawCell;
