"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var coreutils_1 = require("@phosphor/coreutils");
var widgets_1 = require("@phosphor/widgets");
var virtualdom_1 = require("@phosphor/virtualdom");
var _1 = require(".");
/**
 * The class name added to a JSONEditor instance.
 */
var JSONEDITOR_CLASS = 'jp-JSONEditor';
/**
 * The class name added to a focused JSONEditor instance.
 */
var FOCUSED_CLASS = 'jp-mod-focused';
/**
 * The class name added when the Metadata editor contains invalid JSON.
 */
var ERROR_CLASS = 'jp-mod-error';
/**
 * The class name added to the editor host node.
 */
var HOST_CLASS = 'jp-JSONEditor-host';
/**
 * The class name added to the header area.
 */
var HEADER_CLASS = 'jp-JSONEditor-header';
/**
 * The class name added to the title node.
 */
var TITLE_CLASS = 'jp-JSONEditor-title';
/**
 * The class name added to the collapser node.
 */
var COLLAPSER_CLASS = 'jp-JSONEditor-collapser';
/**
 * The class name added to the collapser node that is enabled.
 */
var COLLAPSE_ENABLED_CLASS = 'jp-mod-collapse-enabled';
/**
 * The class name added to the revert button.
 */
var REVERT_CLASS = 'jp-JSONEditor-revertButton';
/**
 * The class name added to the commit button.
 */
var COMMIT_CLASS = 'jp-JSONEditor-commitButton';
/**
 * The class name added to collapsed items.
 */
var COLLAPSED_CLASS = 'jp-mod-collapsed';
/**
 * A widget for editing observable JSON.
 */
var JSONEditor = (function (_super) {
    __extends(JSONEditor, _super);
    /**
     * Construct a new JSON editor.
     */
    function JSONEditor(options) {
        var _this = _super.call(this, { node: Private.createEditorNode(options) }) || this;
        _this._dataDirty = false;
        _this._inputDirty = false;
        _this._source = null;
        _this._originalValue = coreutils_1.JSONExt.emptyObject;
        _this._changeGuard = false;
        var host = _this.editorHostNode;
        var model = new _1.CodeEditor.Model();
        model.value.text = 'No data!';
        model.mimeType = 'application/json';
        model.value.changed.connect(_this._onValueChanged, _this);
        _this.model = model;
        _this.editor = options.editorFactory({ host: host, model: model });
        _this.editor.setOption('readOnly', true);
        _this.collapsible = !!options.collapsible;
        return _this;
    }
    Object.defineProperty(JSONEditor.prototype, "editorTitle", {
        /**
         * The title of the editor.
         */
        get: function () {
            return this.titleNode.textContent || '';
        },
        set: function (value) {
            this.titleNode.textContent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(JSONEditor.prototype, "editorHostNode", {
        /**
         * Get the editor host node used by the JSON editor.
         */
        get: function () {
            return this.node.getElementsByClassName(HOST_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(JSONEditor.prototype, "headerNode", {
        /**
         * Get the header node used by the JSON editor.
         */
        get: function () {
            return this.node.getElementsByClassName(HEADER_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(JSONEditor.prototype, "titleNode", {
        /**
         * Get the title node used by the JSON editor.
         */
        get: function () {
            return this.node.getElementsByClassName(TITLE_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(JSONEditor.prototype, "collapserNode", {
        /**
         * Get the collapser node used by the JSON editor.
         */
        get: function () {
            return this.node.getElementsByClassName(COLLAPSER_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(JSONEditor.prototype, "revertButtonNode", {
        /**
         * Get the revert button used by the JSON editor.
         */
        get: function () {
            return this.node.getElementsByClassName(REVERT_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(JSONEditor.prototype, "commitButtonNode", {
        /**
         * Get the commit button used by the JSON editor.
         */
        get: function () {
            return this.node.getElementsByClassName(COMMIT_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(JSONEditor.prototype, "source", {
        /**
         * The observable source.
         */
        get: function () {
            return this._source;
        },
        set: function (value) {
            if (this._source === value) {
                return;
            }
            if (this._source) {
                this._source.changed.disconnect(this._onSourceChanged, this);
            }
            this._source = value;
            this.editor.setOption('readOnly', value === null);
            if (value) {
                value.changed.connect(this._onSourceChanged, this);
            }
            this._setValue();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(JSONEditor.prototype, "isDirty", {
        /**
         * Get whether the editor is dirty.
         */
        get: function () {
            return this._dataDirty || this._inputDirty;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the notebook panel's node. It should
     * not be called directly by user code.
     */
    JSONEditor.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'blur':
                this._evtBlur(event);
                break;
            case 'click':
                this._evtClick(event);
                break;
            case 'focus':
                this._toggleFocused();
            default:
                break;
        }
    };
    /**
     * Handle `after-attach` messages for the widget.
     */
    JSONEditor.prototype.onAfterAttach = function (msg) {
        var node = this.editorHostNode;
        node.addEventListener('blur', this, true);
        node.addEventListener('focus', this, true);
        this.revertButtonNode.hidden = true;
        this.commitButtonNode.hidden = true;
        this.headerNode.addEventListener('click', this);
    };
    /**
     * Handle `before-detach` messages for the widget.
     */
    JSONEditor.prototype.onBeforeDetach = function (msg) {
        var node = this.editorHostNode;
        node.removeEventListener('blur', this, true);
        this.headerNode.removeEventListener('click', this);
    };
    /**
     * Handle a change to the metadata of the source.
     */
    JSONEditor.prototype._onSourceChanged = function (sender, args) {
        if (this._changeGuard) {
            return;
        }
        if (this._inputDirty || this.editor.hasFocus()) {
            this._dataDirty = true;
            return;
        }
        this._setValue();
    };
    /**
     * Handle change events.
     */
    JSONEditor.prototype._onValueChanged = function () {
        var valid = true;
        try {
            var value = JSON.parse(this.editor.model.value.text);
            this.removeClass(ERROR_CLASS);
            this._inputDirty = (!this._changeGuard && !coreutils_1.JSONExt.deepEqual(value, this._originalValue));
        }
        catch (err) {
            this.addClass(ERROR_CLASS);
            this._inputDirty = true;
            valid = false;
        }
        this.revertButtonNode.hidden = !this._inputDirty;
        this.commitButtonNode.hidden = !valid || !this._inputDirty;
    };
    JSONEditor.prototype._toggleFocused = function () {
        var node = this.editorHostNode;
        var codeMirror = node.getElementsByClassName('CodeMirror-wrap');
        var focused = !codeMirror[0].classList.contains('CodeMirror-focused');
        if (focused) {
            node.classList.add(FOCUSED_CLASS);
        }
        else {
            node.classList.remove(FOCUSED_CLASS);
        }
    };
    /**
     * Handle blur events for the text area.
     */
    JSONEditor.prototype._evtBlur = function (event) {
        // Update the metadata if necessary.
        if (!this._inputDirty && this._dataDirty) {
            this._setValue();
        }
        this._toggleFocused();
    };
    /**
     * Handle click events for the buttons.
     */
    JSONEditor.prototype._evtClick = function (event) {
        var target = event.target;
        switch (target) {
            case this.revertButtonNode:
                this._setValue();
                break;
            case this.commitButtonNode:
                if (!this.commitButtonNode.hidden && !this.hasClass(ERROR_CLASS)) {
                    this._changeGuard = true;
                    this._mergeContent();
                    this._changeGuard = false;
                    this._setValue();
                }
                break;
            case this.titleNode:
            case this.collapserNode:
                if (this.collapsible) {
                    var collapser = this.collapserNode;
                    if (collapser.classList.contains(COLLAPSED_CLASS)) {
                        collapser.classList.remove(COLLAPSED_CLASS);
                        this.editorHostNode.classList.remove(COLLAPSED_CLASS);
                    }
                    else {
                        collapser.classList.add(COLLAPSED_CLASS);
                        this.editorHostNode.classList.add(COLLAPSED_CLASS);
                    }
                }
                break;
            default:
                break;
        }
    };
    /**
     * Merge the user content.
     */
    JSONEditor.prototype._mergeContent = function () {
        var model = this.editor.model;
        var current = this._source ? this._source.toJSON() : {};
        var old = this._originalValue;
        var user = JSON.parse(model.value.text);
        var source = this.source;
        if (!source) {
            return;
        }
        // If it is in user and has changed from old, set in current.
        for (var key in user) {
            if (!coreutils_1.JSONExt.deepEqual(user[key], old[key] || null)) {
                current[key] = user[key];
            }
        }
        // If it was in old and is not in user, remove from current.
        for (var key in old) {
            if (!(key in user)) {
                delete current[key];
                source.delete(key);
            }
        }
        // Set the values.
        for (var key in current) {
            source.set(key, current[key]);
        }
    };
    /**
     * Set the value given the owner contents.
     */
    JSONEditor.prototype._setValue = function () {
        this._dataDirty = false;
        this._inputDirty = false;
        this.revertButtonNode.hidden = true;
        this.commitButtonNode.hidden = true;
        this.removeClass(ERROR_CLASS);
        var model = this.editor.model;
        var content = this._source ? this._source.toJSON() : {};
        this._changeGuard = true;
        if (content === void 0) {
            model.value.text = 'No data!';
            this._originalValue = coreutils_1.JSONExt.emptyObject;
        }
        else {
            var value = JSON.stringify(content, null, 4);
            model.value.text = value;
            this._originalValue = content;
        }
        this.editor.refresh();
        this._changeGuard = false;
        this.commitButtonNode.hidden = true;
        this.revertButtonNode.hidden = true;
    };
    return JSONEditor;
}(widgets_1.Widget));
exports.JSONEditor = JSONEditor;
/**
 * The namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * Create the node for the JSON Editor.
     */
    function createEditorNode(options) {
        var revertTitle = 'Revert changes to data';
        var confirmTitle = 'Commit changes to data';
        var collapseClass = COLLAPSER_CLASS;
        if (options.collapsible) {
            collapseClass += " " + COLLAPSE_ENABLED_CLASS;
        }
        return virtualdom_1.VirtualDOM.realize(virtualdom_1.h.div({ className: JSONEDITOR_CLASS }, virtualdom_1.h.div({ className: HEADER_CLASS }, virtualdom_1.h.span({ className: TITLE_CLASS }, options.title || ''), virtualdom_1.h.span({ className: collapseClass }), virtualdom_1.h.span({ className: REVERT_CLASS, title: revertTitle }), virtualdom_1.h.span({ className: COMMIT_CLASS, title: confirmTitle })), virtualdom_1.h.div({ className: HOST_CLASS })));
    }
    Private.createEditorNode = createEditorNode;
})(Private || (Private = {}));
