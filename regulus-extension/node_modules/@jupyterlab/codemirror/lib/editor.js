"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var CodeMirror = require("codemirror");
var coreutils_1 = require("@phosphor/coreutils");
var algorithm_1 = require("@phosphor/algorithm");
var disposable_1 = require("@phosphor/disposable");
var signaling_1 = require("@phosphor/signaling");
var codeeditor_1 = require("@jupyterlab/codeeditor");
var coreutils_2 = require("@jupyterlab/coreutils");
var mode_1 = require("./mode");
require("codemirror/addon/edit/matchbrackets.js");
require("codemirror/addon/edit/closebrackets.js");
require("codemirror/addon/comment/comment.js");
require("codemirror/addon/search/searchcursor");
require("codemirror/addon/search/search");
require("codemirror/keymap/emacs.js");
require("codemirror/keymap/sublime.js");
require("codemirror/keymap/vim.js");
/**
 * The class name added to CodeMirrorWidget instances.
 */
var EDITOR_CLASS = 'jp-CodeMirrorEditor';
/**
 * The class name added to read only cell editor widgets.
 */
var READ_ONLY_CLASS = 'jp-mod-readOnly';
/**
 * The class name for the hover box for collaborator cursors.
 */
var COLLABORATOR_CURSOR_CLASS = 'jp-CollaboratorCursor';
/**
 * The class name for the hover box for collaborator cursors.
 */
var COLLABORATOR_HOVER_CLASS = 'jp-CollaboratorCursor-hover';
/**
 * The key code for the up arrow key.
 */
var UP_ARROW = 38;
/**
 * The key code for the down arrow key.
 */
var DOWN_ARROW = 40;
/**
 * The time that a collaborator name hover persists.
 */
var HOVER_TIMEOUT = 1000;
/**
 * CodeMirror editor.
 */
var CodeMirrorEditor = (function () {
    /**
     * Construct a CodeMirror editor.
     */
    function CodeMirrorEditor(options) {
        var _this = this;
        /**
         * A signal emitted when either the top or bottom edge is requested.
         */
        this.edgeRequested = new signaling_1.Signal(this);
        this.selectionMarkers = {};
        this._keydownHandlers = new Array();
        this._changeGuard = false;
        this._uuid = '';
        this._needsRefresh = false;
        this._isDisposed = false;
        var host = this.host = options.host;
        host.classList.add(EDITOR_CLASS);
        host.classList.add('jp-Editor');
        host.addEventListener('focus', this, true);
        host.addEventListener('scroll', this, true);
        this._uuid = options.uuid || coreutils_2.uuid();
        // Handle selection style.
        var style = options.selectionStyle || {};
        this._selectionStyle = __assign({}, codeeditor_1.CodeEditor.defaultSelectionStyle, style);
        var model = this._model = options.model;
        var editor = this._editor = CodeMirror(host, {});
        Private.handleConfig(editor, options.config || {});
        var doc = editor.getDoc();
        // Handle initial values for text, mimetype, and selections.
        doc.setValue(model.value.text);
        this._onMimeTypeChanged();
        this._onCursorActivity();
        // Connect to changes.
        model.value.changed.connect(this._onValueChanged, this);
        model.mimeTypeChanged.connect(this._onMimeTypeChanged, this);
        model.selections.changed.connect(this._onSelectionsChanged, this);
        CodeMirror.on(editor, 'keydown', function (editor, event) {
            var index = algorithm_1.ArrayExt.findFirstIndex(_this._keydownHandlers, function (handler) {
                if (handler(_this, event) === true) {
                    event.preventDefault();
                    return true;
                }
                return false;
            });
            if (index === -1) {
                _this.onKeydown(event);
            }
        });
        CodeMirror.on(editor, 'cursorActivity', function () { return _this._onCursorActivity(); });
        CodeMirror.on(editor.getDoc(), 'beforeChange', function (instance, change) {
            _this._beforeDocChanged(instance, change);
        });
        CodeMirror.on(editor.getDoc(), 'change', function (instance, change) {
            // Manually refresh after setValue to make sure editor is properly sized.
            if (change.origin === 'setValue' && _this.hasFocus()) {
                _this.refresh();
            }
            if (_this._model.value.text !== editor.getDoc().getValue()) {
                console.error('Uh oh, the string model is out of sync: ', {
                    model: _this._model.value.text,
                    view: editor.getDoc().getValue()
                });
            }
        });
        // Manually refresh on paste to make sure editor is properly sized.
        editor.getWrapperElement().addEventListener('paste', function () {
            if (_this.hasFocus()) {
                _this.refresh();
            }
        });
    }
    Object.defineProperty(CodeMirrorEditor.prototype, "uuid", {
        /**
         * The uuid of this editor;
         */
        get: function () {
            return this._uuid;
        },
        set: function (value) {
            this._uuid = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CodeMirrorEditor.prototype, "selectionStyle", {
        /**
         * The selection style of this editor.
         */
        get: function () {
            return this._selectionStyle;
        },
        set: function (value) {
            this._selectionStyle = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CodeMirrorEditor.prototype, "editor", {
        /**
         * Get the codemirror editor wrapped by the editor.
         */
        get: function () {
            return this._editor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CodeMirrorEditor.prototype, "doc", {
        /**
         * Get the codemirror doc wrapped by the widget.
         */
        get: function () {
            return this._editor.getDoc();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CodeMirrorEditor.prototype, "lineCount", {
        /**
         * Get the number of lines in the editor.
         */
        get: function () {
            return this.doc.lineCount();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CodeMirrorEditor.prototype, "model", {
        /**
         * Returns a model for this editor.
         */
        get: function () {
            return this._model;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CodeMirrorEditor.prototype, "lineHeight", {
        /**
         * The height of a line in the editor in pixels.
         */
        get: function () {
            return this._editor.defaultTextHeight();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CodeMirrorEditor.prototype, "charWidth", {
        /**
         * The widget of a character in the editor in pixels.
         */
        get: function () {
            return this._editor.defaultCharWidth();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CodeMirrorEditor.prototype, "isDisposed", {
        /**
         * Tests whether the editor is disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the widget.
     */
    CodeMirrorEditor.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        this.host.removeEventListener('focus', this, true);
        this.host.removeEventListener('scroll', this, true);
        this._keydownHandlers.length = 0;
        signaling_1.Signal.clearData(this);
    };
    /**
     * Get a config option for the editor.
     */
    CodeMirrorEditor.prototype.getOption = function (option) {
        return Private.getOption(this.editor, option);
    };
    /**
     * Set a config option for the editor.
     */
    CodeMirrorEditor.prototype.setOption = function (option, value) {
        Private.setOption(this.editor, option, value);
    };
    /**
     * Returns the content for the given line number.
     */
    CodeMirrorEditor.prototype.getLine = function (line) {
        return this.doc.getLine(line);
    };
    /**
     * Find an offset for the given position.
     */
    CodeMirrorEditor.prototype.getOffsetAt = function (position) {
        return this.doc.indexFromPos({
            ch: position.column,
            line: position.line
        });
    };
    /**
     * Find a position fot the given offset.
     */
    CodeMirrorEditor.prototype.getPositionAt = function (offset) {
        var _a = this.doc.posFromIndex(offset), ch = _a.ch, line = _a.line;
        return { line: line, column: ch };
    };
    /**
     * Undo one edit (if any undo events are stored).
     */
    CodeMirrorEditor.prototype.undo = function () {
        this.doc.undo();
    };
    /**
     * Redo one undone edit.
     */
    CodeMirrorEditor.prototype.redo = function () {
        this.doc.redo();
    };
    /**
     * Clear the undo history.
     */
    CodeMirrorEditor.prototype.clearHistory = function () {
        this.doc.clearHistory();
    };
    /**
     * Brings browser focus to this editor text.
     */
    CodeMirrorEditor.prototype.focus = function () {
        this._editor.focus();
    };
    /**
     * Test whether the editor has keyboard focus.
     */
    CodeMirrorEditor.prototype.hasFocus = function () {
        return this._editor.hasFocus();
    };
    /**
     * Explicitly blur the editor.
     */
    CodeMirrorEditor.prototype.blur = function () {
        this._editor.getInputField().blur();
    };
    /**
     * Repaint editor.
     */
    CodeMirrorEditor.prototype.refresh = function () {
        this._editor.refresh();
        this._needsRefresh = false;
    };
    /**
     * Refresh the editor if it is focused;
     * otherwise postpone refreshing till focusing.
     */
    CodeMirrorEditor.prototype.resizeToFit = function () {
        if (this.hasFocus()) {
            this.refresh();
        }
        else {
            this._needsRefresh = true;
        }
        this._clearHover();
    };
    /**
     * Add a keydown handler to the editor.
     *
     * @param handler - A keydown handler.
     *
     * @returns A disposable that can be used to remove the handler.
     */
    CodeMirrorEditor.prototype.addKeydownHandler = function (handler) {
        var _this = this;
        this._keydownHandlers.push(handler);
        return new disposable_1.DisposableDelegate(function () {
            algorithm_1.ArrayExt.removeAllWhere(_this._keydownHandlers, function (val) { return val === handler; });
        });
    };
    /**
     * Set the size of the editor in pixels.
     */
    CodeMirrorEditor.prototype.setSize = function (dimension) {
        if (dimension) {
            this._editor.setSize(dimension.width, dimension.height);
        }
        else {
            this._editor.setSize(null, null);
        }
        this._needsRefresh = false;
    };
    /**
     * Reveal the given position in the editor.
     */
    CodeMirrorEditor.prototype.revealPosition = function (position) {
        var cmPosition = this._toCodeMirrorPosition(position);
        this._editor.scrollIntoView(cmPosition);
    };
    /**
     * Reveal the given selection in the editor.
     */
    CodeMirrorEditor.prototype.revealSelection = function (selection) {
        var range = this._toCodeMirrorRange(selection);
        this._editor.scrollIntoView(range);
    };
    /**
     * Get the window coordinates given a cursor position.
     */
    CodeMirrorEditor.prototype.getCoordinateForPosition = function (position) {
        var pos = this._toCodeMirrorPosition(position);
        var rect = this.editor.charCoords(pos, 'page');
        return rect;
    };
    /**
     * Get the cursor position given window coordinates.
     *
     * @param coordinate - The desired coordinate.
     *
     * @returns The position of the coordinates, or null if not
     *   contained in the editor.
     */
    CodeMirrorEditor.prototype.getPositionForCoordinate = function (coordinate) {
        return this._toPosition(this.editor.coordsChar(coordinate)) || null;
    };
    /**
     * Returns the primary position of the cursor, never `null`.
     */
    CodeMirrorEditor.prototype.getCursorPosition = function () {
        var cursor = this.doc.getCursor();
        return this._toPosition(cursor);
    };
    /**
     * Set the primary position of the cursor.
     *
     * #### Notes
     * This will remove any secondary cursors.
     */
    CodeMirrorEditor.prototype.setCursorPosition = function (position) {
        var cursor = this._toCodeMirrorPosition(position);
        this.doc.setCursor(cursor);
        // If the editor does not have focus, this cursor change
        // will get screened out in _onCursorsChanged(). Make an
        // exception for this method.
        if (!this.editor.hasFocus()) {
            this.model.selections.set(this.uuid, this.getSelections());
        }
    };
    /**
     * Returns the primary selection, never `null`.
     */
    CodeMirrorEditor.prototype.getSelection = function () {
        return this.getSelections()[0];
    };
    /**
     * Set the primary selection. This will remove any secondary cursors.
     */
    CodeMirrorEditor.prototype.setSelection = function (selection) {
        this.setSelections([selection]);
    };
    /**
     * Gets the selections for all the cursors, never `null` or empty.
     */
    CodeMirrorEditor.prototype.getSelections = function () {
        var _this = this;
        var selections = this.doc.listSelections();
        if (selections.length > 0) {
            return selections.map(function (selection) { return _this._toSelection(selection); });
        }
        var cursor = this.doc.getCursor();
        var selection = this._toSelection({ anchor: cursor, head: cursor });
        return [selection];
    };
    /**
     * Sets the selections for all the cursors, should not be empty.
     * Cursors will be removed or added, as necessary.
     * Passing an empty array resets a cursor position to the start of a document.
     */
    CodeMirrorEditor.prototype.setSelections = function (selections) {
        var cmSelections = this._toCodeMirrorSelections(selections);
        this.doc.setSelections(cmSelections, 0);
    };
    /**
     * Execute a codemirror command on the editor.
     *
     * @param command - The name of the command to execute.
     */
    CodeMirrorEditor.prototype.execCommand = function (command) {
        this._editor.execCommand(command);
    };
    /**
     * Handle keydown events from the editor.
     */
    CodeMirrorEditor.prototype.onKeydown = function (event) {
        var position = this.getCursorPosition();
        var line = position.line, column = position.column;
        if (line === 0 && column === 0 && event.keyCode === UP_ARROW) {
            if (!event.shiftKey) {
                this.edgeRequested.emit('top');
            }
            return false;
        }
        var lastLine = this.lineCount - 1;
        var lastCh = this.getLine(lastLine).length;
        if (line === lastLine && column === lastCh
            && event.keyCode === DOWN_ARROW) {
            if (!event.shiftKey) {
                this.edgeRequested.emit('bottom');
            }
            return false;
        }
        return false;
    };
    /**
     * Converts selections to code mirror selections.
     */
    CodeMirrorEditor.prototype._toCodeMirrorSelections = function (selections) {
        var _this = this;
        if (selections.length > 0) {
            return selections.map(function (selection) { return _this._toCodeMirrorSelection(selection); });
        }
        var position = { line: 0, ch: 0 };
        return [{ anchor: position, head: position }];
    };
    /**
     * Handles a mime type change.
     */
    CodeMirrorEditor.prototype._onMimeTypeChanged = function () {
        var mime = this._model.mimeType;
        var editor = this._editor;
        mode_1.Mode.ensure(mime).then(function (spec) {
            editor.setOption('mode', spec.mime);
        });
        var isCode = (mime !== 'text/plain') && (mime !== 'text/x-ipythongfm');
        editor.setOption('matchBrackets', isCode);
        editor.setOption('autoCloseBrackets', isCode);
        var extraKeys = editor.getOption('extraKeys') || {};
        if (isCode) {
            extraKeys['Backspace'] = 'delSpaceToPrevTabStop';
        }
        else {
            delete extraKeys['Backspace'];
        }
        editor.setOption('extraKeys', extraKeys);
    };
    /**
     * Handles a selections change.
     */
    CodeMirrorEditor.prototype._onSelectionsChanged = function (selections, args) {
        var uuid = args.key;
        if (uuid !== this.uuid) {
            this._cleanSelections(uuid);
            if (args.type !== 'remove' && args.newValue) {
                this._markSelections(uuid, args.newValue);
            }
        }
    };
    /**
     * Clean selections for the given uuid.
     */
    CodeMirrorEditor.prototype._cleanSelections = function (uuid) {
        var markers = this.selectionMarkers[uuid];
        if (markers) {
            markers.forEach(function (marker) { marker.clear(); });
        }
        delete this.selectionMarkers[uuid];
    };
    /**
     * Marks selections.
     */
    CodeMirrorEditor.prototype._markSelections = function (uuid, selections) {
        var _this = this;
        var markers = [];
        // If we are marking selections corresponding to an active hover,
        // remove it.
        if (uuid === this._hoverId) {
            this._clearHover();
        }
        // If we can id the selection to a specific collaborator,
        // use that information.
        var collaborator;
        if (this._model.modelDB.collaborators) {
            collaborator = this._model.modelDB.collaborators.get(uuid);
        }
        // Style each selection for the uuid.
        selections.forEach(function (selection) {
            // Only render selections if the start is not equal to the end.
            // In that case, we don't need to render the cursor.
            if (!coreutils_1.JSONExt.deepEqual(selection.start, selection.end)) {
                var _a = _this._toCodeMirrorSelection(selection), anchor = _a.anchor, head = _a.head;
                var markerOptions = void 0;
                if (collaborator) {
                    markerOptions = _this._toTextMarkerOptions(__assign({}, selection.style, { color: collaborator.color }));
                }
                else {
                    markerOptions = _this._toTextMarkerOptions(selection.style);
                }
                markers.push(_this.doc.markText(anchor, head, markerOptions));
            }
            else if (collaborator) {
                var caret = _this._getCaret(collaborator);
                markers.push(_this.doc.setBookmark(_this._toCodeMirrorPosition(selection.end), { widget: caret }));
            }
        });
        this.selectionMarkers[uuid] = markers;
    };
    /**
     * Handles a cursor activity event.
     */
    CodeMirrorEditor.prototype._onCursorActivity = function () {
        // Only add selections if the editor has focus. This avoids unwanted
        // triggering of cursor activity due to collaborator actions.
        if (this._editor.hasFocus()) {
            var selections = this.getSelections();
            this.model.selections.set(this.uuid, selections);
        }
    };
    /**
     * Converts a code mirror selection to an editor selection.
     */
    CodeMirrorEditor.prototype._toSelection = function (selection) {
        return {
            uuid: this.uuid,
            start: this._toPosition(selection.anchor),
            end: this._toPosition(selection.head),
            style: this.selectionStyle
        };
    };
    /**
     * Converts the selection style to a text marker options.
     */
    CodeMirrorEditor.prototype._toTextMarkerOptions = function (style) {
        var r = parseInt(style.color.slice(1, 3), 16);
        var g = parseInt(style.color.slice(3, 5), 16);
        var b = parseInt(style.color.slice(5, 7), 16);
        var css = "background-color: rgba( " + r + ", " + g + ", " + b + ", 0.15)";
        return {
            className: style.className,
            title: style.displayName,
            css: css
        };
    };
    /**
     * Converts an editor selection to a code mirror selection.
     */
    CodeMirrorEditor.prototype._toCodeMirrorSelection = function (selection) {
        // Selections only appear to render correctly if the anchor
        // is before the head in the document. That is, reverse selections
        // do not appear as intended.
        var forward = (selection.start.line < selection.end.line) ||
            (selection.start.line === selection.end.line &&
                selection.start.column <= selection.end.column);
        var anchor = forward ? selection.start : selection.end;
        var head = forward ? selection.end : selection.start;
        return {
            anchor: this._toCodeMirrorPosition(anchor),
            head: this._toCodeMirrorPosition(head)
        };
    };
    /**
     * Converts an editor selection to a code mirror selection.
     */
    CodeMirrorEditor.prototype._toCodeMirrorRange = function (range) {
        return {
            from: this._toCodeMirrorPosition(range.start),
            to: this._toCodeMirrorPosition(range.end)
        };
    };
    /**
     * Convert a code mirror position to an editor position.
     */
    CodeMirrorEditor.prototype._toPosition = function (position) {
        return {
            line: position.line,
            column: position.ch
        };
    };
    /**
     * Convert an editor position to a code mirror position.
     */
    CodeMirrorEditor.prototype._toCodeMirrorPosition = function (position) {
        return {
            line: position.line,
            ch: position.column
        };
    };
    /**
     * Handle model value changes.
     */
    CodeMirrorEditor.prototype._onValueChanged = function (value, args) {
        if (this._changeGuard) {
            return;
        }
        this._changeGuard = true;
        var doc = this.doc;
        switch (args.type) {
            case 'insert':
                var pos = doc.posFromIndex(args.start);
                doc.replaceRange(args.value, pos, pos);
                break;
            case 'remove':
                var from = doc.posFromIndex(args.start);
                var to = doc.posFromIndex(args.end);
                doc.replaceRange('', from, to);
                break;
            case 'set':
                doc.setValue(args.value);
                break;
            default:
                break;
        }
        this._changeGuard = false;
    };
    /**
     * Handles document changes.
     */
    CodeMirrorEditor.prototype._beforeDocChanged = function (doc, change) {
        if (this._changeGuard) {
            return;
        }
        this._changeGuard = true;
        var value = this._model.value;
        var start = doc.indexFromPos(change.from);
        var end = doc.indexFromPos(change.to);
        var inserted = change.text.join('\n');
        if (end !== start) {
            value.remove(start, end);
        }
        if (inserted) {
            value.insert(start, inserted);
        }
        this._changeGuard = false;
    };
    /**
     * Handle the DOM events for the editor.
     *
     * @param event - The DOM event sent to the editor.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the editor's DOM node. It should
     * not be called directly by user code.
     */
    CodeMirrorEditor.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'focus':
                this._evtFocus(event);
                break;
            case 'scroll':
                this._evtScroll();
                break;
            default:
                break;
        }
    };
    /**
     * Handle `focus` events for the editor.
     */
    CodeMirrorEditor.prototype._evtFocus = function (event) {
        if (this._needsRefresh) {
            this.refresh();
        }
    };
    /**
     * Handle `scroll` events for the editor.
     */
    CodeMirrorEditor.prototype._evtScroll = function () {
        // Remove any active hover.
        this._clearHover();
    };
    /**
     * Clear the hover for a caret, due to things like
     * scrolling, resizing, deactivation, etc, where
     * the position is no longer valid.
     */
    CodeMirrorEditor.prototype._clearHover = function () {
        if (this._caretHover) {
            window.clearTimeout(this._hoverTimeout);
            document.body.removeChild(this._caretHover);
            this._caretHover = null;
        }
    };
    /**
     * Construct a caret element representing the position
     * of a collaborator's cursor.
     */
    CodeMirrorEditor.prototype._getCaret = function (collaborator) {
        var _this = this;
        var name = collaborator ? collaborator.displayName : 'Anonymous';
        var color = collaborator ? collaborator.color : this._selectionStyle.color;
        var caret = document.createElement('span');
        caret.className = COLLABORATOR_CURSOR_CLASS;
        caret.style.borderBottomColor = color;
        caret.onmouseenter = function () {
            _this._clearHover();
            _this._hoverId = collaborator.sessionId;
            var rect = caret.getBoundingClientRect();
            // Construct and place the hover box.
            var hover = document.createElement('div');
            hover.className = COLLABORATOR_HOVER_CLASS;
            hover.style.left = String(rect.left) + 'px';
            hover.style.top = String(rect.bottom) + 'px';
            hover.textContent = name;
            hover.style.backgroundColor = color;
            // If the user mouses over the hover, take over the timer.
            hover.onmouseenter = function () {
                window.clearTimeout(_this._hoverTimeout);
            };
            hover.onmouseleave = function () {
                _this._hoverTimeout = window.setTimeout(function () {
                    _this._clearHover();
                }, HOVER_TIMEOUT);
            };
            _this._caretHover = hover;
            document.body.appendChild(hover);
        };
        caret.onmouseleave = function () {
            _this._hoverTimeout = window.setTimeout(function () {
                _this._clearHover();
            }, HOVER_TIMEOUT);
        };
        return caret;
    };
    return CodeMirrorEditor;
}());
exports.CodeMirrorEditor = CodeMirrorEditor;
/**
 * The namespace for `CodeMirrorEditor` statics.
 */
(function (CodeMirrorEditor) {
    /**
     * The default configuration options for an editor.
     */
    CodeMirrorEditor.defaultConfig = __assign({}, codeeditor_1.CodeEditor.defaultConfig, { mode: 'null', theme: 'jupyter', smartIndent: true, electricChars: true, keyMap: 'default', extraKeys: null, gutters: Object.freeze([]), fixedGutter: true, showCursorWhenSelecting: false, coverGutterNextToScrollbar: false, dragDrop: true, lineSeparator: null, scrollbarStyle: 'native', lineWiseCopyCut: true });
    /**
     * Add a command to CodeMirror.
     *
     * @param name - The name of the command to add.
     *
     * @param command - The command function.
     */
    function addCommand(name, command) {
        CodeMirror.commands[name] = command;
    }
    CodeMirrorEditor.addCommand = addCommand;
})(CodeMirrorEditor = exports.CodeMirrorEditor || (exports.CodeMirrorEditor = {}));
exports.CodeMirrorEditor = CodeMirrorEditor;
/**
 * The namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * Handle the codemirror configuration options.
     */
    function handleConfig(editor, config) {
        var fullConfig = __assign({}, CodeMirrorEditor.defaultConfig, config);
        var key;
        for (key in fullConfig) {
            Private.setOption(editor, key, fullConfig[key]);
        }
    }
    Private.handleConfig = handleConfig;
    /**
     * Indent or insert a tab as appropriate.
     */
    function indentMoreOrinsertTab(cm) {
        var doc = cm.getDoc();
        var from = doc.getCursor('from');
        var to = doc.getCursor('to');
        var sel = !posEq(from, to);
        if (sel) {
            CodeMirror.commands['indentMore'](cm);
            return;
        }
        // Check for start of line.
        var line = doc.getLine(from.line);
        var before = line.slice(0, from.ch);
        if (/^\s*$/.test(before)) {
            CodeMirror.commands['indentMore'](cm);
        }
        else {
            CodeMirror.commands['insertSoftTab'](cm);
        }
    }
    Private.indentMoreOrinsertTab = indentMoreOrinsertTab;
    /**
     * Delete spaces to the previous tab stob in a codemirror editor.
     */
    function delSpaceToPrevTabStop(cm) {
        var doc = cm.getDoc();
        var from = doc.getCursor('from');
        var to = doc.getCursor('to');
        var sel = !posEq(from, to);
        if (sel) {
            var ranges = doc.listSelections();
            for (var i = ranges.length - 1; i >= 0; i--) {
                var head = ranges[i].head;
                var anchor = ranges[i].anchor;
                doc.replaceRange('', CodeMirror.Pos(head.line, head.ch), CodeMirror.Pos(anchor.line, anchor.ch));
            }
            return;
        }
        var cur = doc.getCursor();
        var tabsize = cm.getOption('tabSize');
        var chToPrevTabStop = cur.ch - (Math.ceil(cur.ch / tabsize) - 1) * tabsize;
        from = { ch: cur.ch - chToPrevTabStop, line: cur.line };
        var select = doc.getRange(from, cur);
        if (select.match(/^\ +$/) !== null) {
            doc.replaceRange('', from, cur);
        }
        else {
            CodeMirror.commands['delCharBefore'](cm);
        }
    }
    Private.delSpaceToPrevTabStop = delSpaceToPrevTabStop;
    /**
     * Test whether two CodeMirror positions are equal.
     */
    function posEq(a, b) {
        return a.line === b.line && a.ch === b.ch;
    }
    Private.posEq = posEq;
    ;
    /**
     * Get a config option for the editor.
     */
    function getOption(editor, option) {
        switch (option) {
            case 'lineWrap':
                return editor.getOption('lineWrapping');
            case 'insertSpaces':
                return !editor.getOption('indentWithTabs');
            case 'tabSize':
                return editor.getOption('indentUnit');
            case 'autoClosingBrackets':
                return editor.getOption('autoCloseBrackets');
            default:
                return editor.getOption(option);
        }
    }
    Private.getOption = getOption;
    /**
     * Set a config option for the editor.
     */
    function setOption(editor, option, value) {
        switch (option) {
            case 'lineWrap':
                editor.setOption('lineWrapping', value);
                break;
            case 'tabSize':
                editor.setOption('indentUnit', value);
                break;
            case 'insertSpaces':
                editor.setOption('indentWithTabs', !value);
                break;
            case 'autoClosingBrackets':
                editor.setOption('autoCloseBrackets', value);
                break;
            case 'readOnly':
                var el = editor.getWrapperElement();
                if (value) {
                    el.classList.add(READ_ONLY_CLASS);
                }
                else {
                    el.classList.remove(READ_ONLY_CLASS);
                    editor.getInputField().blur();
                }
                editor.setOption(option, value);
                break;
            default:
                editor.setOption(option, value);
                break;
        }
    }
    Private.setOption = setOption;
})(Private || (Private = {}));
/**
 * Add a CodeMirror command to delete until previous non blanking space
 * character or first multiple of tabsize tabstop.
 */
CodeMirrorEditor.addCommand('delSpaceToPrevTabStop', Private.delSpaceToPrevTabStop);
/**
 * Add a CodeMirror command to indent or insert a tab as appropriate.
 */
CodeMirrorEditor.addCommand('indentMoreOrinsertTab', Private.indentMoreOrinsertTab);
