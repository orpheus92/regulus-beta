"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var algorithm_1 = require("@phosphor/algorithm");
var coreutils_1 = require("@phosphor/coreutils");
var disposable_1 = require("@phosphor/disposable");
var vdom = require("@phosphor/virtualdom");
var apputils_1 = require("@jupyterlab/apputils");
require("../style/index.css");
/* tslint:disable */
/**
 * We have configured the TSX transform to look for the h function in the local
 * module.
 */
var h = vdom.h;
/* tslint:enable */
/**
 * The class name added to Launcher instances.
 */
var LAUNCHER_CLASS = 'jp-Launcher';
/**
 * The known categories of launcher items and their default ordering.
 */
var KNOWN_CATEGORIES = ['Notebook', 'Console', 'Other'];
/**
 * These laucher item categories are known to have kernels, so the kernel icons
 * are used.
 */
var KERNEL_CATEGORIES = ['Notebook', 'Console'];
/**
 * The command IDs used by the launcher plugin.
 */
var CommandIDs;
(function (CommandIDs) {
    CommandIDs.show = 'launcher:show';
})(CommandIDs = exports.CommandIDs || (exports.CommandIDs = {}));
;
/* tslint:disable */
/**
 * The launcher token.
 */
exports.ILauncher = new coreutils_1.Token('jupyter.services.launcher');
/**
 * LauncherModel keeps track of the path to working directory and has a list of
 * LauncherItems, which the Launcher will render.
 */
var LauncherModel = (function (_super) {
    __extends(LauncherModel, _super);
    /**
     * Create a new launcher model.
     */
    function LauncherModel() {
        var _this = _super.call(this) || this;
        _this._items = [];
        return _this;
    }
    /**
     * Add a command item to the launcher, and trigger re-render event for parent
     * widget.
     *
     * @param options - The specification options for a launcher item.
     *
     * @returns A disposable that will remove the item from Launcher, and trigger
     * re-render event for parent widget.
     *
     */
    LauncherModel.prototype.add = function (options) {
        var _this = this;
        // Create a copy of the options to circumvent mutations to the original.
        var item = Private.createItem(options);
        this._items.push(item);
        this.stateChanged.emit(void 0);
        return new disposable_1.DisposableDelegate(function () {
            algorithm_1.ArrayExt.removeFirstOf(_this._items, item);
            _this.stateChanged.emit(void 0);
        });
    };
    /**
     * Return an iterator of launcher items.
     */
    LauncherModel.prototype.items = function () {
        return new algorithm_1.ArrayIterator(this._items);
    };
    return LauncherModel;
}(apputils_1.VDomModel));
exports.LauncherModel = LauncherModel;
/**
 * A virtual-DOM-based widget for the Launcher.
 */
var Launcher = (function (_super) {
    __extends(Launcher, _super);
    /**
     * Construct a new launcher widget.
     */
    function Launcher(options) {
        var _this = _super.call(this) || this;
        _this._pending = false;
        _this.cwd = options.cwd;
        _this._callback = options.callback;
        _this.addClass(LAUNCHER_CLASS);
        return _this;
    }
    Object.defineProperty(Launcher.prototype, "pending", {
        /**
         * Whether there is a pending item being launched.
         */
        get: function () {
            return this._pending;
        },
        set: function (value) {
            this._pending = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handle `'activate-request'` messages.
     */
    Launcher.prototype.onActivateRequest = function (msg) {
        this.node.tabIndex = -1;
        this.node.focus();
    };
    /**
     * Render the launcher to virtual DOM nodes.
     */
    Launcher.prototype.render = function () {
        var _this = this;
        // Bail if there is no model.
        if (!this.model) {
            return [];
        }
        // First group-by categories
        var categories = Object.create(null);
        algorithm_1.each(this.model.items(), function (item, index) {
            var cat = item.category || 'Other';
            if (!(cat in categories)) {
                categories[cat] = [];
            }
            categories[cat].push(item);
        });
        // Within each category sort by rank
        for (var cat in categories) {
            categories[cat] = categories[cat].sort(Private.sortCmp);
        }
        // Variable to help create sections
        var sections = [];
        var section;
        // Assemble the final ordered list of categories, beginning with
        // KNOWN_CATEGORIES.
        var orderedCategories = [];
        algorithm_1.each(KNOWN_CATEGORIES, function (cat, index) {
            orderedCategories.push(cat);
        });
        for (var cat in categories) {
            if (KNOWN_CATEGORIES.indexOf(cat) === -1) {
                orderedCategories.push(cat);
            }
        }
        // Now create the sections for each category
        algorithm_1.each(orderedCategories, function (cat, index) {
            var iconClass = categories[cat][0].iconClass + " " +
                'jp-Launcher-sectionIcon jp-Launcher-icon';
            var kernel = KERNEL_CATEGORIES.indexOf(cat) > -1;
            if (cat in categories) {
                section = (h("div", { className: 'jp-Launcher-section' },
                    h("div", { className: 'jp-Launcher-sectionHeader' },
                        kernel && h("div", { className: iconClass }),
                        h("h2", { className: 'jp-Launcher-sectionTitle' }, cat)),
                    h("div", { className: 'jp-Launcher-cardContainer' }, algorithm_1.toArray(algorithm_1.map(categories[cat], function (item) {
                        return Card(kernel, item, _this, _this._callback);
                    })))));
                sections.push(section);
            }
        });
        // Wrap the sections in body and content divs.
        return (h("div", { className: 'jp-Launcher-body' },
            h("div", { className: 'jp-Launcher-content' },
                h("div", { className: 'jp-Launcher-cwd' },
                    h("h3", null, this.cwd)),
                sections)));
    };
    return Launcher;
}(apputils_1.VDomRenderer));
exports.Launcher = Launcher;
/**
 * A pure tsx component for a launcher card.
 *
 * @param kernel - whether the item takes uses a kernel.
 *
 * @param item - the launcher item to render.
 *
 * @param launcher - the Launcher instance to which this is added.
 *
 * @param launcherCallback - a callback to call after an item has been launched.
 *
 * @returns a vdom `VirtualElement` for the launcher card.
 */
function Card(kernel, item, launcher, launcherCallback) {
    // Build the onclick handler.
    var onclick = function () {
        // If an item has already been launched,
        // don't try to launch another.
        if (launcher.pending === true) {
            return;
        }
        launcher.pending = true;
        var callback = item.callback;
        var value = callback(launcher.cwd, item.name);
        Promise.resolve(value).then(function (widget) {
            launcherCallback(widget);
            launcher.dispose();
        }).catch(function (err) {
            launcher.pending = false;
            throw err;
        });
    };
    // Add a data attribute for the category
    var dataset = { category: item.category || 'Other' };
    // Return the VDOM element.
    return (h("div", { className: 'jp-LauncherCard', title: item.displayName, onclick: onclick, dataset: dataset },
        h("div", { className: 'jp-LauncherCard-icon' },
            (item.kernelIconUrl && kernel) &&
                h("img", { src: item.kernelIconUrl, className: 'jp-Launcher-kernelIcon' }),
            (!item.kernelIconUrl && !kernel) &&
                h("div", { className: item.iconClass + " jp-Launcher-icon" }),
            (!item.kernelIconUrl && kernel) &&
                h("div", { className: 'jp-LauncherCard-noKernelIcon' }, item.displayName[0].toUpperCase())),
        h("div", { className: 'jp-LauncherCard-label', title: item.displayName }, item.displayName)));
}
/**
 * The namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * Create an item given item options.
     */
    function createItem(options) {
        return __assign({}, options, { category: options.category || '', name: options.name || options.name, iconClass: options.iconClass || '', iconLabel: options.iconLabel || '', rank: options.rank !== undefined ? options.rank : Infinity });
    }
    Private.createItem = createItem;
    /**
     * A sort comparison function for a launcher item.
     */
    function sortCmp(a, b) {
        // First, compare by rank.
        var r1 = a.rank;
        var r2 = b.rank;
        if (r1 !== r2 && r1 !== undefined && r2 !== undefined) {
            return r1 < r2 ? -1 : 1; // Infinity safe
        }
        // Finally, compare by display name.
        return a.displayName.localeCompare(b.displayName);
    }
    Private.sortCmp = sortCmp;
})(Private || (Private = {}));
