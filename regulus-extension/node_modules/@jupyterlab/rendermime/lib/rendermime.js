"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var coreutils_1 = require("@jupyterlab/coreutils");
var apputils_1 = require("@jupyterlab/apputils");
var mimemodel_1 = require("./mimemodel");
/**
 * An object which manages mime renderer factories.
 *
 * This object is used to render mime models using registered mime
 * renderers, selecting the preferred mime renderer to render the
 * model into a widget.
 *
 * #### Notes
 * This class is not intended to be subclassed.
 */
var RenderMime = (function () {
    /**
     * Construct a new rendermime.
     *
     * @param options - The options for initializing the instance.
     */
    function RenderMime(options) {
        if (options === void 0) { options = {}; }
        this._id = 0;
        this._ranks = {};
        this._types = null;
        this._factories = {};
        // Parse the options.
        this.resolver = options.resolver || null;
        this.linkHandler = options.linkHandler || null;
        this.sanitizer = options.sanitizer || apputils_1.defaultSanitizer;
        // Add the initial factories.
        if (options.initialFactories) {
            for (var _i = 0, _a = options.initialFactories; _i < _a.length; _i++) {
                var factory = _a[_i];
                this.addFactory(factory);
            }
        }
    }
    Object.defineProperty(RenderMime.prototype, "mimeTypes", {
        /**
         * The ordered list of mimeTypes.
         */
        get: function () {
            return this._types || (this._types = Private.sortedTypes(this._ranks));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Find the preferred mime type for a mime bundle.
     *
     * @param bundle - The bundle of mime data.
     *
     * @param preferSafe - Whether to prefer a safe factory.
     *
     * @returns The preferred mime type from the available factories,
     *   or `undefined` if the mime type cannot be rendered.
     */
    RenderMime.prototype.preferredMimeType = function (bundle, preferSafe) {
        // Try to find a safe factory first, if preferred.
        if (preferSafe) {
            for (var _i = 0, _a = this.mimeTypes; _i < _a.length; _i++) {
                var mt = _a[_i];
                if (mt in bundle && this._factories[mt].safe) {
                    return mt;
                }
            }
        }
        // Otherwise, search for the best factory among all factories.
        for (var _b = 0, _c = this.mimeTypes; _b < _c.length; _b++) {
            var mt = _c[_b];
            if (mt in bundle) {
                return mt;
            }
        }
        // Otherwise, no matching mime type exists.
        return undefined;
    };
    /**
     * Create a renderer for a mime type.
     *
     * @param mimeType - The mime type of interest.
     *
     * @returns A new renderer for the given mime type.
     *
     * @throws An error if no factory exists for the mime type.
     */
    RenderMime.prototype.createRenderer = function (mimeType) {
        // Throw an error if no factory exists for the mime type.
        if (!(mimeType in this._factories)) {
            throw new Error("No factory for mime type: '" + mimeType + "'");
        }
        // Invoke the best factory for the given mime type.
        return this._factories[mimeType].createRenderer({
            mimeType: mimeType,
            resolver: this.resolver,
            sanitizer: this.sanitizer,
            linkHandler: this.linkHandler
        });
    };
    /**
     * Create a new mime model.  This is a convenience method.
     *
     * @options - The options used to create the model.
     *
     * @returns A new mime model.
     */
    RenderMime.prototype.createModel = function (options) {
        if (options === void 0) { options = {}; }
        return new mimemodel_1.MimeModel(options);
    };
    /**
     * Create a clone of this rendermime instance.
     *
     * @param options - The options for configuring the clone.
     *
     * @returns A new independent clone of the rendermime.
     */
    RenderMime.prototype.clone = function (options) {
        if (options === void 0) { options = {}; }
        // Create the clone.
        var clone = new RenderMime({
            resolver: options.resolver || this.resolver || undefined,
            sanitizer: options.sanitizer || this.sanitizer || undefined,
            linkHandler: options.linkHandler || this.linkHandler || undefined
        });
        // Clone the internal state.
        clone._factories = __assign({}, this._factories);
        clone._ranks = __assign({}, this._ranks);
        clone._id = this._id;
        // Return the cloned object.
        return clone;
    };
    /**
     * Get the renderer factory registered for a mime type.
     *
     * @param mimeType - The mime type of interest.
     *
     * @returns The factory for the mime type, or `undefined`.
     */
    RenderMime.prototype.getFactory = function (mimeType) {
        return this._factories[mimeType];
    };
    /**
     * Add a renderer factory to the rendermime.
     *
     * @param factory - The renderer factory of interest.
     *
     * @param rank - The rank of the renderer. A lower rank indicates
     *   a higher priority for rendering. The default is `100`.
     *
     * #### Notes
     * The renderer will replace an existing renderer for the given
     * mimeType.
     */
    RenderMime.prototype.addFactory = function (factory, rank) {
        if (rank === void 0) { rank = 100; }
        for (var _i = 0, _a = factory.mimeTypes; _i < _a.length; _i++) {
            var mt = _a[_i];
            this._factories[mt] = factory;
            this._ranks[mt] = { rank: rank, id: this._id++ };
        }
        this._types = null;
    };
    /**
     * Remove the factory for a mime type.
     *
     * @param mimeType - The mime type of interest.
     */
    RenderMime.prototype.removeFactory = function (mimeType) {
        delete this._factories[mimeType];
        delete this._ranks[mimeType];
        this._types = null;
    };
    return RenderMime;
}());
exports.RenderMime = RenderMime;
/**
 * The namespace for `RenderMime` class statics.
 */
(function (RenderMime) {
    /**
     * A default resolver that uses a session and a contents manager.
     */
    var UrlResolver = (function () {
        /**
         * Create a new url resolver for a console.
         */
        function UrlResolver(options) {
            this._session = options.session;
            this._contents = options.contents;
        }
        /**
         * Resolve a relative url to a correct server path.
         */
        UrlResolver.prototype.resolveUrl = function (url) {
            if (coreutils_1.URLExt.isLocal(url)) {
                var cwd = coreutils_1.PathExt.dirname(this._session.path);
                url = coreutils_1.PathExt.resolve(cwd, url);
            }
            return Promise.resolve(url);
        };
        /**
         * Get the download url of a given absolute server path.
         */
        UrlResolver.prototype.getDownloadUrl = function (path) {
            if (coreutils_1.URLExt.isLocal(path)) {
                return this._contents.getDownloadUrl(path);
            }
            return Promise.resolve(path);
        };
        return UrlResolver;
    }());
    RenderMime.UrlResolver = UrlResolver;
})(RenderMime = exports.RenderMime || (exports.RenderMime = {}));
exports.RenderMime = RenderMime;
/**
 * The namespace for the module implementation details.
 */
var Private;
(function (Private) {
    /**
     * Get the mime types in the map, ordered by rank.
     */
    function sortedTypes(map) {
        return Object.keys(map).sort(function (a, b) {
            var p1 = map[a];
            var p2 = map[b];
            if (p1.rank !== p2.rank) {
                return p1.rank - p2.rank;
            }
            return p1.id - p2.id;
        });
    }
    Private.sortedTypes = sortedTypes;
})(Private || (Private = {}));
