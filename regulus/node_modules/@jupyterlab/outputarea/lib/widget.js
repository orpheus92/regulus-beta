"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var signaling_1 = require("@phosphor/signaling");
var widgets_1 = require("@phosphor/widgets");
var widgets_2 = require("@phosphor/widgets");
var services_1 = require("@jupyterlab/services");
/**
 * The class name added to an output area widget.
 */
var OUTPUT_AREA_CLASS = 'jp-OutputArea';
/**
 * The class name added to the direction children of OutputArea
 */
var OUTPUT_AREA_ITEM_CLASS = 'jp-OutputArea-child';
/**
 * The class name added to actual outputs
 */
var OUTPUT_AREA_OUTPUT_CLASS = 'jp-OutputArea-output';
/**
 * The class name added to prompt children of OutputArea.
 */
var OUTPUT_AREA_PROMPT_CLASS = 'jp-OutputArea-prompt';
/**
 * The class name added to OutputPrompt.
 */
var OUTPUT_PROMPT_CLASS = 'jp-OutputPrompt';
/**
 * The class name added to an execution result.
 */
var EXECUTE_CLASS = 'jp-OutputArea-executeResult';
/**
 * The class name added stdin items of OutputArea
 */
var OUTPUT_AREA_STDIN_ITEM_CLASS = 'jp-OutputArea-stdin-item';
/**
 * The class name added to stdin widgets.
 */
var STDIN_CLASS = 'jp-Stdin';
/**
 * The class name added to stdin data prompt nodes.
 */
var STDIN_PROMPT_CLASS = 'jp-Stdin-prompt';
/**
 * The class name added to stdin data input nodes.
 */
var STDIN_INPUT_CLASS = 'jp-Stdin-input';
/**
 * The class name added to stdin rendered text nodes.
 */
var STDIN_RENDERED_CLASS = 'jp-Stdin-rendered';
/******************************************************************************
 * OutputArea
 ******************************************************************************/
/**
 * An output area widget.
 *
 * #### Notes
 * The widget model must be set separately and can be changed
 * at any time.  Consumers of the widget must account for a
 * `null` model, and may want to listen to the `modelChanged`
 * signal.
 */
var OutputArea = (function (_super) {
    __extends(OutputArea, _super);
    /**
     * Construct an output area widget.
     */
    function OutputArea(options) {
        var _this = _super.call(this) || this;
        /**
         * A public signal used to indicate the number of outputs has changed.
         *
         * #### Notes
         * This is useful for parents who want to apply styling based on the number
         * of outputs. Emits the current number of outputs.
         */
        _this.outputLengthChanged = new signaling_1.Signal(_this);
        _this._minHeightTimeout = null;
        _this._future = null;
        _this._displayIdMap = new Map();
        var model = _this.model = options.model;
        _this.addClass(OUTPUT_AREA_CLASS);
        _this.rendermime = options.rendermime;
        _this.contentFactory = (options.contentFactory || OutputArea.defaultContentFactory);
        _this.layout = new widgets_1.PanelLayout();
        for (var i = 0; i < model.length; i++) {
            var output = model.get(i);
            _this._insertOutput(i, output);
        }
        model.changed.connect(_this.onModelChanged, _this);
        return _this;
    }
    Object.defineProperty(OutputArea.prototype, "widgets", {
        /**
         * A read-only sequence of the chidren widgets in the output area.
         */
        get: function () {
            return this.layout.widgets;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutputArea.prototype, "future", {
        /**
         * The kernel future associated with the output area.
         */
        get: function () {
            return this._future;
        },
        set: function (value) {
            var _this = this;
            // Bail if the model is disposed.
            if (this.model.isDisposed) {
                throw Error('Model is disposed');
            }
            if (this._future === value) {
                return;
            }
            if (this._future) {
                this._future.dispose();
            }
            this._future = value;
            this.model.clear();
            // Make sure there were no input widgets.
            if (this.widgets.length) {
                this._clear();
                this.outputLengthChanged.emit(this.model.length);
            }
            // Handle published messages.
            value.onIOPub = this._onIOPub.bind(this);
            // Handle the execute reply.
            value.onReply = this._onExecuteReply.bind(this);
            // Handle stdin.
            value.onStdin = function (msg) {
                if (services_1.KernelMessage.isInputRequestMsg(msg)) {
                    _this._onInputRequest(msg, value);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources used by the output area.
     */
    OutputArea.prototype.dispose = function () {
        if (this._future) {
            this._future.dispose();
        }
        this._future = null;
        this._displayIdMap.clear();
        _super.prototype.dispose.call(this);
    };
    /**
     * Follow changes on the model state.
     */
    OutputArea.prototype.onModelChanged = function (sender, args) {
        switch (args.type) {
            case 'add':
                this._insertOutput(args.newIndex, args.newValues[0]);
                this.outputLengthChanged.emit(this.model.length);
                break;
            case 'remove':
                // Only clear is supported by the model.
                if (this.widgets.length) {
                    this._clear();
                    this.outputLengthChanged.emit(this.model.length);
                }
                break;
            case 'set':
                this._setOutput(args.newIndex, args.newValues[0]);
                this.outputLengthChanged.emit(this.model.length);
                break;
            default:
                break;
        }
    };
    /**
     * Clear the widget inputs and outputs.
     */
    OutputArea.prototype._clear = function () {
        var _this = this;
        // Bail if there is no work to do.
        if (!this.widgets.length) {
            return;
        }
        // Remove all of our widgets.
        var length = this.widgets.length;
        for (var i = 0; i < length; i++) {
            var widget = this.widgets[0];
            widget.parent = null;
            widget.dispose();
        }
        // Clear the display id map.
        this._displayIdMap.clear();
        // When an output area is cleared and then quickly replaced with new
        // content (as happens with @interact in widgets, for example), the
        // quickly changing height can make the page jitter.
        // We introduce a small delay in the minimum height
        // to prevent this jitter.
        var rect = this.node.getBoundingClientRect();
        this.node.style.minHeight = rect.height + "px";
        if (this._minHeightTimeout) {
            clearTimeout(this._minHeightTimeout);
        }
        this._minHeightTimeout = window.setTimeout(function () {
            if (_this.isDisposed) {
                return;
            }
            _this.node.style.minHeight = '';
        }, 50);
    };
    /**
     * Handle an iopub message.
     */
    OutputArea.prototype._onIOPub = function (msg) {
        var model = this.model;
        var msgType = msg.header.msg_type;
        var output;
        var transient = (msg.content.transient || {});
        var displayId = transient['display_id'];
        var targets;
        switch (msgType) {
            case 'execute_result':
            case 'display_data':
            case 'stream':
            case 'error':
                output = msg.content;
                output.output_type = msgType;
                model.add(output);
                break;
            case 'clear_output':
                var wait = msg.content.wait;
                model.clear(wait);
                break;
            case 'update_display_data':
                output = msg.content;
                output.output_type = msgType;
                targets = this._displayIdMap.get(displayId);
                if (targets) {
                    for (var _i = 0, targets_1 = targets; _i < targets_1.length; _i++) {
                        var index = targets_1[_i];
                        model.set(index, output);
                    }
                }
                break;
            default:
                break;
        }
        if (displayId && msgType === 'display_data') {
            targets = this._displayIdMap.get(displayId) || [];
            targets.push(model.length - 1);
            this._displayIdMap.set(displayId, targets);
        }
    };
    /**
     * Handle an execute reply message.
     */
    OutputArea.prototype._onExecuteReply = function (msg) {
        // API responses that contain a pager are special cased and their type
        // is overriden from 'execute_reply' to 'display_data' in order to
        // render output.
        var model = this.model;
        var content = msg.content;
        var payload = content && content.payload;
        if (!payload || !payload.length) {
            return;
        }
        var pages = payload.filter(function (i) { return i.source === 'page'; });
        if (!pages.length) {
            return;
        }
        var page = JSON.parse(JSON.stringify(pages[0]));
        var output = {
            output_type: 'display_data',
            data: page.data,
            metadata: {}
        };
        model.add(output);
    };
    /**
     * Handle an input request from a kernel.
     */
    OutputArea.prototype._onInputRequest = function (msg, future) {
        // Add an output widget to the end.
        var factory = this.contentFactory;
        var stdinPrompt = msg.content.prompt;
        var password = msg.content.password;
        var panel = new widgets_1.Panel();
        panel.addClass(OUTPUT_AREA_ITEM_CLASS);
        panel.addClass(OUTPUT_AREA_STDIN_ITEM_CLASS);
        var prompt = factory.createOutputPrompt();
        prompt.addClass(OUTPUT_AREA_PROMPT_CLASS);
        panel.addWidget(prompt);
        var input = factory.createStdin({ prompt: stdinPrompt, password: password, future: future });
        input.addClass(OUTPUT_AREA_OUTPUT_CLASS);
        panel.addWidget(input);
        var layout = this.layout;
        layout.addWidget(panel);
    };
    /**
     * Update an output in place.
     */
    OutputArea.prototype._setOutput = function (index, model) {
        var layout = this.layout;
        var widgets = this.widgets;
        // Skip any stdin widgets to find the correct index.
        for (var i = 0; i < index; i++) {
            if (widgets[i].hasClass(OUTPUT_AREA_STDIN_ITEM_CLASS)) {
                index++;
            }
        }
        layout.widgets[index].dispose();
        this._insertOutput(index, model);
    };
    /**
     * Render and insert a single output into the layout.
     */
    OutputArea.prototype._insertOutput = function (index, model) {
        var output = this._createOutputItem(model);
        output.toggleClass(EXECUTE_CLASS, model.executionCount !== null);
        var layout = this.layout;
        layout.insertWidget(index, output);
    };
    /**
     * Create an output item with a prompt and actual output
     */
    OutputArea.prototype._createOutputItem = function (model) {
        var panel = new widgets_1.Panel();
        panel.addClass(OUTPUT_AREA_ITEM_CLASS);
        var prompt = this.contentFactory.createOutputPrompt();
        prompt.executionCount = model.executionCount;
        prompt.addClass(OUTPUT_AREA_PROMPT_CLASS);
        panel.addWidget(prompt);
        var mimeType = this.rendermime.preferredMimeType(model.data, !model.trusted);
        if (mimeType) {
            var output = this.rendermime.createRenderer(mimeType);
            output.renderModel(model);
            output.addClass(OUTPUT_AREA_OUTPUT_CLASS);
            panel.addWidget(output);
        }
        return panel;
    };
    return OutputArea;
}(widgets_2.Widget));
exports.OutputArea = OutputArea;
/**
 * A namespace for OutputArea statics.
 */
(function (OutputArea) {
    /**
     * Execute code on an output area.
     */
    function execute(code, output, session) {
        // Override the default for `stop_on_error`.
        var content = {
            code: code,
            stop_on_error: true
        };
        if (!session.kernel) {
            return Promise.reject('Session has no kernel.');
        }
        var future = session.kernel.requestExecute(content, false);
        output.future = future;
        return future.done;
    }
    OutputArea.execute = execute;
    /**
     * The default implementation of `IContentFactory`.
     */
    var ContentFactory = (function () {
        function ContentFactory() {
        }
        /**
         * Create the output prompt for the widget.
         */
        ContentFactory.prototype.createOutputPrompt = function () {
            return new OutputPrompt();
        };
        /**
         * Create an stdin widget.
         */
        ContentFactory.prototype.createStdin = function (options) {
            return new Stdin(options);
        };
        return ContentFactory;
    }());
    OutputArea.ContentFactory = ContentFactory;
    /**
     * The default `ContentFactory` instance.
     */
    OutputArea.defaultContentFactory = new ContentFactory();
})(OutputArea = exports.OutputArea || (exports.OutputArea = {}));
exports.OutputArea = OutputArea;
/**
 * The default output prompt implementation
 */
var OutputPrompt = (function (_super) {
    __extends(OutputPrompt, _super);
    /*
      * Create an output prompt widget.
      */
    function OutputPrompt() {
        var _this = _super.call(this) || this;
        _this._executionCount = null;
        _this.addClass(OUTPUT_PROMPT_CLASS);
        return _this;
    }
    Object.defineProperty(OutputPrompt.prototype, "executionCount", {
        /**
         * The execution count for the prompt.
         */
        get: function () {
            return this._executionCount;
        },
        set: function (value) {
            this._executionCount = value;
            if (value === null) {
                this.node.textContent = '';
            }
            else {
                this.node.textContent = "Out[" + value + "]:";
            }
        },
        enumerable: true,
        configurable: true
    });
    return OutputPrompt;
}(widgets_2.Widget));
exports.OutputPrompt = OutputPrompt;
/**
 * The default stdin widget.
 */
var Stdin = (function (_super) {
    __extends(Stdin, _super);
    /**
     * Construct a new input widget.
     */
    function Stdin(options) {
        var _this = _super.call(this, { node: Private.createInputWidgetNode() }) || this;
        _this._future = null;
        _this._input = null;
        _this.addClass(STDIN_CLASS);
        var text = _this.node.firstChild;
        text.textContent = options.prompt;
        _this._input = _this.node.lastChild;
        if (options.password) {
            _this._input.type = 'password';
        }
        _this._future = options.future;
        return _this;
    }
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the dock panel's node. It should
     * not be called directly by user code.
     */
    Stdin.prototype.handleEvent = function (event) {
        var input = this._input;
        if (event.type === 'keydown') {
            if (event.keyCode === 13) {
                this._future.sendInputReply({
                    value: input.value
                });
                var rendered = document.createElement('span');
                rendered.className = STDIN_RENDERED_CLASS;
                if (input.type === 'password') {
                    rendered.textContent = Array(input.value.length + 1).join('Â·');
                }
                else {
                    rendered.textContent = input.value;
                }
                this.node.replaceChild(rendered, input);
            }
        }
    };
    /**
     * Handle `after-attach` messages sent to the widget.
     */
    Stdin.prototype.onAfterAttach = function (msg) {
        this._input.addEventListener('keydown', this);
        this.update();
    };
    /**
     * Handle `update-request` messages sent to the widget.
     */
    Stdin.prototype.onUpdateRequest = function (msg) {
        this._input.focus();
    };
    /**
     * Handle `before-detach` messages sent to the widget.
     */
    Stdin.prototype.onBeforeDetach = function (msg) {
        this._input.removeEventListener('keydown', this);
    };
    return Stdin;
}(widgets_2.Widget));
exports.Stdin = Stdin;
/******************************************************************************
 * Private namespace
 ******************************************************************************/
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * Create the node for an InputWidget.
     */
    function createInputWidgetNode() {
        var node = document.createElement('div');
        var prompt = document.createElement('span');
        prompt.className = STDIN_PROMPT_CLASS;
        var input = document.createElement('input');
        input.className = STDIN_INPUT_CLASS;
        node.appendChild(prompt);
        node.appendChild(input);
        return node;
    }
    Private.createInputWidgetNode = createInputWidgetNode;
})(Private || (Private = {}));
