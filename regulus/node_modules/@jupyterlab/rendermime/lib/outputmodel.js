"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
var coreutils_1 = require("@phosphor/coreutils");
var signaling_1 = require("@phosphor/signaling");
var coreutils_2 = require("@jupyterlab/coreutils");
/**
 * The default implementation of a notebook output model.
 */
var OutputModel = (function () {
    /**
     * Construct a new output model.
     */
    function OutputModel(options) {
        this._changed = new signaling_1.Signal(this);
        this._raw = {};
        var _a = Private.getBundleOptions(options), data = _a.data, metadata = _a.metadata, trusted = _a.trusted;
        this._data = new coreutils_2.ObservableJSON({ values: data });
        this._rawData = data;
        this._metadata = new coreutils_2.ObservableJSON({ values: metadata });
        this._rawMetadata = metadata;
        this.trusted = trusted;
        // Make a copy of the data.
        var value = options.value;
        for (var key in value) {
            // Ignore data and metadata that were stripped.
            switch (key) {
                case 'data':
                case 'metadata':
                    break;
                default:
                    this._raw[key] = Private.extract(value, key);
            }
        }
        this.type = value.output_type;
        if (coreutils_2.nbformat.isExecuteResult(value)) {
            this.executionCount = value.execution_count;
        }
        else {
            this.executionCount = null;
        }
    }
    Object.defineProperty(OutputModel.prototype, "changed", {
        /**
         * A signal emitted when the output model changes.
         */
        get: function () {
            return this._changed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources used by the output model.
     */
    OutputModel.prototype.dispose = function () {
        this._data.dispose();
        this._metadata.dispose();
        signaling_1.Signal.clearData(this);
    };
    Object.defineProperty(OutputModel.prototype, "data", {
        /**
         * The data associated with the model.
         */
        get: function () {
            return this._rawData;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutputModel.prototype, "metadata", {
        /**
         * The metadata associated with the model.
         */
        get: function () {
            return this._rawMetadata;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set the data associated with the model.
     *
     * #### Notes
     * Depending on the implementation of the mime model,
     * this call may or may not have deferred effects,
     */
    OutputModel.prototype.setData = function (options) {
        if (options.data) {
            this._updateObservable(this._data, options.data);
            this._rawData = options.data;
        }
        if (options.metadata) {
            this._updateObservable(this._metadata, options.metadata);
            this._rawMetadata = options.metadata;
        }
        this._changed.emit(void 0);
    };
    /**
     * Serialize the model to JSON.
     */
    OutputModel.prototype.toJSON = function () {
        var output = {};
        for (var key in this._raw) {
            output[key] = Private.extract(this._raw, key);
        }
        switch (this.type) {
            case 'display_data':
            case 'execute_result':
            case 'update_display_data':
                output['data'] = this.data;
                output['metadata'] = this.metadata;
                break;
            default:
                break;
        }
        // Remove transient data.
        delete output['transient'];
        return output;
    };
    /**
     * Update an observable JSON object using a readonly JSON object.
     */
    OutputModel.prototype._updateObservable = function (observable, data) {
        var oldKeys = observable.keys();
        var newKeys = Object.keys(data);
        // Handle removed keys.
        for (var _i = 0, oldKeys_1 = oldKeys; _i < oldKeys_1.length; _i++) {
            var key = oldKeys_1[_i];
            if (newKeys.indexOf(key) === -1) {
                observable.delete(key);
            }
        }
        // Handle changed data.
        for (var _a = 0, newKeys_1 = newKeys; _a < newKeys_1.length; _a++) {
            var key = newKeys_1[_a];
            var oldValue = observable.get(key);
            var newValue = data[key];
            if (oldValue !== newValue) {
                observable.set(key, newValue);
            }
        }
    };
    return OutputModel;
}());
exports.OutputModel = OutputModel;
/**
 * The namespace for OutputModel statics.
 */
(function (OutputModel) {
    /**
     * Get the data for an output.
     *
     * @params output - A kernel output message payload.
     *
     * @returns - The data for the payload.
     */
    function getData(output) {
        return Private.getData(output);
    }
    OutputModel.getData = getData;
    /**
     * Get the metadata from an output message.
     *
     * @params output - A kernel output message payload.
     *
     * @returns - The metadata for the payload.
     */
    function getMetadata(output) {
        return Private.getMetadata(output);
    }
    OutputModel.getMetadata = getMetadata;
})(OutputModel = exports.OutputModel || (exports.OutputModel = {}));
exports.OutputModel = OutputModel;
/**
 * The namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * Get the data from a notebook output.
     */
    function getData(output) {
        var bundle = {};
        if (coreutils_2.nbformat.isExecuteResult(output) || coreutils_2.nbformat.isDisplayData(output) || coreutils_2.nbformat.isDisplayUpdate(output)) {
            bundle = output.data;
        }
        else if (coreutils_2.nbformat.isStream(output)) {
            if (output.name === 'stderr') {
                bundle['application/vnd.jupyter.stderr'] = output.text;
            }
            else {
                bundle['application/vnd.jupyter.stdout'] = output.text;
            }
        }
        else if (coreutils_2.nbformat.isError(output)) {
            var traceback = output.traceback.join('\n');
            bundle['application/vnd.jupyter.stderr'] = (traceback || output.ename + ": " + output.evalue);
        }
        return convertBundle(bundle);
    }
    Private.getData = getData;
    /**
     * Get the metadata from an output message.
     */
    function getMetadata(output) {
        var value = Object.create(null);
        if (coreutils_2.nbformat.isExecuteResult(output) || coreutils_2.nbformat.isDisplayData(output)) {
            for (var key in output.metadata) {
                value[key] = extract(output.metadata, key);
            }
        }
        return value;
    }
    Private.getMetadata = getMetadata;
    /**
     * Get the bundle options given output model options.
     */
    function getBundleOptions(options) {
        var data = getData(options.value);
        var metadata = getMetadata(options.value);
        var trusted = !!options.trusted;
        return { data: data, metadata: metadata, trusted: trusted };
    }
    Private.getBundleOptions = getBundleOptions;
    /**
     * Extract a value from a JSONObject.
     */
    function extract(value, key) {
        var item = value[key];
        if (coreutils_1.JSONExt.isPrimitive(item)) {
            return item;
        }
        return JSON.parse(JSON.stringify(item));
    }
    Private.extract = extract;
    /**
     * Convert a mime bundle to mime data.
     */
    function convertBundle(bundle) {
        var map = Object.create(null);
        for (var mimeType in bundle) {
            var item = bundle[mimeType];
            // Convert multi-line strings to strings.
            if (coreutils_1.JSONExt.isArray(item)) {
                item = item.join('\n');
            }
            else if (!coreutils_1.JSONExt.isPrimitive(item)) {
                item = JSON.parse(JSON.stringify(item));
            }
            map[mimeType] = item;
        }
        return map;
    }
})(Private || (Private = {}));
