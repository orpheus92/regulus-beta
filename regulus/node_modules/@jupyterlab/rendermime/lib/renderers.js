"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
var ansi_up_1 = require("ansi_up");
var marked = require("marked");
var codemirror_1 = require("@jupyterlab/codemirror");
var coreutils_1 = require("@jupyterlab/coreutils");
var latex_1 = require("./latex");
/**
 * Render HTML into a host node.
 *
 * @params options - The options for rendering.
 *
 * @returns A promise which resolves when rendering is complete.
 */
function renderHTML(options) {
    // Unpack the options.
    var host = options.host, source = options.source, trusted = options.trusted, sanitizer = options.sanitizer, resolver = options.resolver, linkHandler = options.linkHandler, shouldTypeset = options.shouldTypeset;
    // Bail early if the source is empty.
    if (!source) {
        host.textContent = '';
        return Promise.resolve(undefined);
    }
    // Sanitize the source if it is not trusted. This removes all
    // `<script>` tags as well as other potentially harmful HTML.
    if (!trusted) {
        source = sanitizer.sanitize(source);
    }
    // Set the inner HTML of the host.
    host.innerHTML = source;
    if (host.getElementsByTagName('script').length > 0) {
        console.warn('JupyterLab does not execute inline JavaScript in HTML output');
    }
    // TODO - arbitrary script execution is disabled for now.
    // Eval any script tags contained in the HTML. This is not done
    // automatically by the browser when script tags are created by
    // setting `innerHTML`. The santizer should have removed all of
    // the script tags for untrusted source, but this extra trusted
    // check is just extra insurance.
    // if (trusted) {
    //   // TODO do we really want to run scripts? Because if so, there
    //   // is really no difference between this and a JS mime renderer.
    //   Private.evalInnerHTMLScriptTags(host);
    // }
    // Handle default behavior of nodes.
    Private.handleDefaults(host);
    // Patch the urls if a resolver is available.
    var promise;
    if (resolver) {
        promise = Private.handleUrls(host, resolver, linkHandler);
    }
    else {
        promise = Promise.resolve(undefined);
    }
    // Return the final rendered promise.
    return promise.then(function () { if (shouldTypeset) {
        latex_1.typeset(host);
    } });
}
exports.renderHTML = renderHTML;
/**
 * Render an image into a host node.
 *
 * @params options - The options for rendering.
 *
 * @returns A promise which resolves when rendering is complete.
 */
function renderImage(options) {
    // Unpack the options.
    var host = options.host, mimeType = options.mimeType, source = options.source, width = options.width, height = options.height, unconfined = options.unconfined;
    // Clear the content in the host.
    host.textContent = '';
    // Create the image element.
    var img = document.createElement('img');
    // Set the source of the image.
    img.src = "data:" + mimeType + ";base64," + source;
    // Set the size of the image if provided.
    if (typeof height === 'number') {
        img.height = height;
    }
    if (typeof width === 'number') {
        img.width = width;
    }
    if (unconfined === true) {
        img.classList.add('jp-mod-unconfined');
    }
    // Add the image to the host.
    host.appendChild(img);
    // Return the rendered promise.
    return Promise.resolve(undefined);
}
exports.renderImage = renderImage;
/**
 * Render LaTeX into a host node.
 *
 * @params options - The options for rendering.
 *
 * @returns A promise which resolves when rendering is complete.
 */
function renderLatex(options) {
    // Unpack the options.
    var host = options.host, source = options.source, shouldTypeset = options.shouldTypeset;
    // Set the source on the node.
    host.textContent = source;
    // Typeset the node if needed.
    if (shouldTypeset) {
        latex_1.typeset(host);
    }
    // Return the rendered promise.
    return Promise.resolve(undefined);
}
exports.renderLatex = renderLatex;
/**
 * Render Markdown into a host node.
 *
 * @params options - The options for rendering.
 *
 * @returns A promise which resolves when rendering is complete.
 */
function renderMarkdown(options) {
    // Unpack the options.
    var host = options.host, source = options.source, trusted = options.trusted, sanitizer = options.sanitizer, resolver = options.resolver, linkHandler = options.linkHandler, shouldTypeset = options.shouldTypeset;
    // Clear the content if there is no source.
    if (!source) {
        host.textContent = '';
        return Promise.resolve(undefined);
    }
    // Separate math from normal markdown text.
    var parts = latex_1.removeMath(source);
    // Render the markdown and handle sanitization.
    return Private.renderMarked(parts['text']).then(function (content) {
        // Restore the math content in the rendered markdown.
        content = latex_1.replaceMath(content, parts['math']);
        // Santize the content it is not trusted.
        if (!trusted) {
            content = sanitizer.sanitize(content);
        }
        // Set the inner HTML of the host.
        host.innerHTML = content;
        if (host.getElementsByTagName('script').length > 0) {
            console.warn('JupyterLab does not execute inline JavaScript in HTML output');
        }
        // TODO arbitrary script execution is disabled for now.
        // Eval any script tags contained in the HTML. This is not done
        // automatically by the browser when script tags are created by
        // setting `innerHTML`. The santizer should have removed all of
        // the script tags for untrusted source, but this extra trusted
        // check is just extra insurance.
        // if (trusted) {
        //   // TODO really want to run scripts?
        //   Private.evalInnerHTMLScriptTags(host);
        // }
        // Handle default behavior of nodes.
        Private.handleDefaults(host);
        // Apply ids to the header nodes.
        Private.headerAnchors(host);
        // Patch the urls if a resolver is available.
        var promise;
        if (resolver) {
            promise = Private.handleUrls(host, resolver, linkHandler);
        }
        else {
            promise = Promise.resolve(undefined);
        }
        // Return the rendered promise.
        return promise;
    }).then(function () { if (shouldTypeset) {
        latex_1.typeset(host);
    } });
}
exports.renderMarkdown = renderMarkdown;
/**
 * Render SVG into a host node.
 *
 * @params options - The options for rendering.
 *
 * @returns A promise which resolves when rendering is complete.
 */
function renderSVG(options) {
    // Unpack the options.
    var host = options.host, source = options.source, trusted = options.trusted, resolver = options.resolver, linkHandler = options.linkHandler, shouldTypeset = options.shouldTypeset, unconfined = options.unconfined;
    // Clear the content if there is no source.
    if (!source) {
        host.textContent = '';
        return Promise.resolve(undefined);
    }
    // Display a message if the source is not trusted.
    if (!trusted) {
        host.textContent = 'Cannot display an untrusted SVG. Maybe you need to run the cell?';
        return Promise.resolve(undefined);
    }
    // Set the inner HTML of the host.
    host.innerHTML = source;
    if (unconfined === true) {
        host.classList.add('jp-mod-unconfined');
    }
    // TODO
    // what about script tags inside the svg?
    // Patch the urls if a resolver is available.
    var promise;
    if (resolver) {
        promise = Private.handleUrls(host, resolver, linkHandler);
    }
    else {
        promise = Promise.resolve(undefined);
    }
    // Return the final rendered promise.
    return promise.then(function () { if (shouldTypeset) {
        latex_1.typeset(host);
    } });
}
exports.renderSVG = renderSVG;
/**
 * Render text into a host node.
 *
 * @params options - The options for rendering.
 *
 * @returns A promise which resolves when rendering is complete.
 */
function renderText(options) {
    // Unpack the options.
    var host = options.host, source = options.source;
    // Escape the terminal codes and HTML tags.
    var data = ansi_up_1.escape_for_html(source);
    // Create the HTML content.
    var content = ansi_up_1.ansi_to_html(data, { use_classes: true });
    // Set the inner HTML for the host node.
    host.innerHTML = "<pre>" + content + "</pre>";
    // Return the rendered promise.
    return Promise.resolve(undefined);
}
exports.renderText = renderText;
/**
 * The namespace for module implementation details.
 */
var Private;
(function (Private) {
    // This is disabled for now until we decide we actually really
    // truly want to allow arbitrary script execution.
    /**
     * Eval the script tags contained in a host populated by `innerHTML`.
     *
     * When script tags are created via `innerHTML`, the browser does not
     * evaluate them when they are added to the page. This function works
     * around that by creating new equivalent script nodes manually, and
     * replacing the originals.
     */
    // export
    // function evalInnerHTMLScriptTags(host: HTMLElement): void {
    //   // Create a snapshot of the current script nodes.
    //   let scripts = toArray(host.getElementsByTagName('script'));
    //   // Loop over each script node.
    //   for (let script of scripts) {
    //     // Skip any scripts which no longer have a parent.
    //     if (!script.parentNode) {
    //       continue;
    //     }
    //     // Create a new script node which will be clone.
    //     let clone = document.createElement('script');
    //     // Copy the attributes into the clone.
    //     let attrs = script.attributes;
    //     for (let i = 0, n = attrs.length; i < n; ++i) {
    //       let { name, value } = attrs[i];
    //       clone.setAttribute(name, value);
    //     }
    //     // Copy the text content into the clone.
    //     clone.textContent = script.textContent;
    //     // Replace the old script in the parent.
    //     script.parentNode.replaceChild(clone, script);
    //   }
    // }
    /**
     * Render markdown for the specified content.
     *
     * @param content - The string of markdown to render.
     *
     * @return A promise which resolves with the rendered content.
     */
    function renderMarked(content) {
        initializeMarked();
        return new Promise(function (resolve, reject) {
            marked(content, function (err, content) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(content);
                }
            });
        });
    }
    Private.renderMarked = renderMarked;
    /**
     * Handle the default behavior of nodes.
     */
    function handleDefaults(node) {
        // Handle anchor elements.
        var anchors = node.getElementsByTagName('a');
        for (var i = 0; i < anchors.length; i++) {
            var path = anchors[i].href;
            if (coreutils_1.URLExt.isLocal(path)) {
                anchors[i].target = '_self';
            }
            else {
                anchors[i].target = '_blank';
            }
        }
    }
    Private.handleDefaults = handleDefaults;
    /**
     * Resolve the relative urls in element `src` and `href` attributes.
     *
     * @param node - The head html element.
     *
     * @param resolver - A url resolver.
     *
     * @param linkHandler - An optional link handler for nodes.
     *
     * @returns a promise fulfilled when the relative urls have been resolved.
     */
    function handleUrls(node, resolver, linkHandler) {
        // Set up an array to collect promises.
        var promises = [];
        // Handle HTML Elements with src attributes.
        var nodes = node.querySelectorAll('*[src]');
        for (var i = 0; i < nodes.length; i++) {
            promises.push(handleAttr(nodes[i], 'src', resolver));
        }
        // Handle anchor elements.
        var anchors = node.getElementsByTagName('a');
        for (var i = 0; i < anchors.length; i++) {
            promises.push(handleAnchor(anchors[i], resolver, linkHandler));
        }
        // Handle link elements.
        var links = node.getElementsByTagName('link');
        for (var i = 0; i < links.length; i++) {
            promises.push(handleAttr(links[i], 'href', resolver));
        }
        // Wait on all promises.
        return Promise.all(promises).then(function () { return undefined; });
    }
    Private.handleUrls = handleUrls;
    /**
     * Apply ids to headers.
     */
    function headerAnchors(node) {
        var headerNames = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
        for (var _i = 0, headerNames_1 = headerNames; _i < headerNames_1.length; _i++) {
            var headerType = headerNames_1[_i];
            var headers = node.getElementsByTagName(headerType);
            for (var i = 0; i < headers.length; i++) {
                var header = headers[i];
                header.id = header.innerHTML.replace(/ /g, '-');
                var anchor = document.createElement('a');
                anchor.target = '_self';
                anchor.textContent = '¶';
                anchor.href = '#' + header.id;
                anchor.classList.add('jp-InternalAnchorLink');
                header.appendChild(anchor);
            }
        }
    }
    Private.headerAnchors = headerAnchors;
    /**
     * Handle a node with a `src` or `href` attribute.
     */
    function handleAttr(node, name, resolver) {
        var source = node.getAttribute(name);
        if (!source || coreutils_1.URLExt.parse(source).protocol === 'data:') {
            return Promise.resolve(undefined);
        }
        node.setAttribute(name, '');
        return resolver.resolveUrl(source).then(function (path) {
            return resolver.getDownloadUrl(path);
        }).then(function (url) {
            node.setAttribute(name, url);
        });
    }
    /**
     * Handle an anchor node.
     */
    function handleAnchor(anchor, resolver, linkHandler) {
        // Get the link path without the location prepended.
        // (e.g. "./foo.md#Header 1" vs "http://localhost:8888/foo.md#Header 1")
        var href = anchor.getAttribute('href');
        // Bail if it is not a file-like url.
        if (!href || href.indexOf('://') !== -1 && href.indexOf('//') === 0) {
            return Promise.resolve(undefined);
        }
        // Remove the hash until we can handle it.
        var hash = anchor.hash;
        if (hash) {
            // Handle internal link in the file.
            if (hash === href) {
                anchor.target = '_self';
                return Promise.resolve(undefined);
            }
            // For external links, remove the hash until we have hash handling.
            href = href.replace(hash, '');
        }
        // Get the appropriate file path.
        return resolver.resolveUrl(href).then(function (path) {
            // Handle the click override.
            if (linkHandler && coreutils_1.URLExt.isLocal(path)) {
                linkHandler.handleLink(anchor, path);
            }
            // Get the appropriate file download path.
            return resolver.getDownloadUrl(path);
        }).then(function (url) {
            // Set the visible anchor.
            anchor.href = url + hash;
        });
    }
    var markedInitialized = false;
    /**
     * Support GitHub flavored Markdown, leave sanitizing to external library.
     */
    function initializeMarked() {
        if (markedInitialized) {
            return;
        }
        markedInitialized = true;
        marked.setOptions({
            gfm: true,
            sanitize: false,
            tables: true,
            // breaks: true; We can't use GFM breaks as it causes problems with tables
            langPrefix: "cm-s-" + codemirror_1.CodeMirrorEditor.defaultConfig.theme + " language-",
            highlight: function (code, lang, callback) {
                var cb = function (err, code) {
                    if (callback) {
                        callback(err, code);
                    }
                    return code;
                };
                if (!lang) {
                    // no language, no highlight
                    return cb(null, code);
                }
                codemirror_1.Mode.ensure(lang).then(function (spec) {
                    var el = document.createElement('div');
                    if (!spec) {
                        console.log("No CodeMirror mode: " + lang);
                        return cb(null, code);
                    }
                    try {
                        codemirror_1.Mode.run(code, spec.mime, el);
                        return cb(null, el.innerHTML);
                    }
                    catch (err) {
                        console.log("Failed to highlight " + lang + " code", err);
                        return cb(err, code);
                    }
                }).catch(function (err) {
                    console.log("No CodeMirror mode: " + lang);
                    console.log("Require CodeMirror mode error: " + err);
                    return cb(null, code);
                });
                return code;
            }
        });
    }
})(Private || (Private = {}));
